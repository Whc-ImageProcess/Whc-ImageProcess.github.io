<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试手撕代码</title>
    <link href="/2023/09/22/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/09/22/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 简易版本 quick sort，面试手撕</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Quick_Sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (begin &gt; end)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> tmp = arr[begin];<br>    <span class="hljs-type">int</span> i = begin;<br>    <span class="hljs-type">int</span> j = end;<br>    <span class="hljs-keyword">while</span> (i != j)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (arr[j] &gt;= tmp &amp;&amp; j &gt; i)<br>            j--;<br>        <span class="hljs-keyword">while</span> (arr[i] &lt;= tmp &amp;&amp; j &gt; i)<br>            i++;<br>        <span class="hljs-keyword">if</span> (j &gt; i)<br>        &#123;<br>            <span class="hljs-type">int</span> t = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = t;<br>        &#125;<br>    &#125;<br>    arr[begin] = arr[i];<br>    arr[i] = tmp;<br>    <span class="hljs-built_in">Quick_Sort</span>(arr, begin, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">Quick_Sort</span>(arr, i + <span class="hljs-number">1</span>, end);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">help</span><span class="hljs-params">(R - L + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> p1 = L;<br>    <span class="hljs-type">int</span> p2 = M + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R)<br>    &#123;<br>        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (p1 &lt;= M)<br>    &#123;<br>        help[i++] = arr[p1++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (p2 &lt;= R)<br>    &#123;<br>        help[i++] = arr[p2++];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        arr[L + i] = help[i];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (L == R)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">process</span>(arr, L, mid);<br>    <span class="hljs-built_in">process</span>(arr, mid + <span class="hljs-number">1</span>, R);<br>    <span class="hljs-built_in">merge</span>(arr, L, mid, R);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">process</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 停止条件：当前来到头结点或者当前节点不在比它的父节点大</span><br>    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>        index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> heapSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; heapSize)<br>    &#123;<br>        <span class="hljs-comment">// two children choose bigger one</span><br>        <span class="hljs-type">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;<br>        <span class="hljs-comment">// 父和较大孩子之间，谁的值大，把下标给largest</span><br>        largest = arr[largest] &gt; arr[index] ? largest : index;<br>        <span class="hljs-keyword">if</span> (index == largest)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr, largest, index);<br>        index = largest;<br>        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// O(N)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-comment">// O(logN)</span><br>        <span class="hljs-built_in">heapInsert</span>(arr, i);<br>    &#125;<br>    <span class="hljs-type">int</span> heapSize = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">swap</span>(arr, <span class="hljs-number">0</span>, --heapSize);<br>    <span class="hljs-comment">// O(N)</span><br>    <span class="hljs-keyword">while</span> (heapSize &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// O(logN)</span><br>        <span class="hljs-built_in">heapify</span>(arr, <span class="hljs-number">0</span>, heapSize);<br>        <span class="hljs-comment">// O(1)</span><br>        <span class="hljs-built_in">swap</span>(arr, <span class="hljs-number">0</span>, --heapSize);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="桶排序（基数排序）"><a href="#桶排序（基数排序）" class="headerlink" title="桶排序（基数排序）"></a>桶排序（基数排序）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxbits</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> max = INT32_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        max = std::<span class="hljs-built_in">max</span>(max, arr[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>)<br>    &#123;<br>        res++;<br>        max /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ((x / (<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, d - <span class="hljs-number">1</span>)) % <span class="hljs-number">10</span>);<br>&#125;<br><span class="hljs-comment">// digit：这一批数中最大的值有多少十进制位</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> digit)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> radix = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 有多少个数准备多少个辅助空间</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bucket</span><span class="hljs-params">(R - L + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">1</span>; d &lt;= digit; d++)<br>    &#123;<br>        <span class="hljs-comment">// 10个空间</span><br>        <span class="hljs-comment">// count[0] 当前位(d位)是0的数字有多少个</span><br>        <span class="hljs-comment">// count[1] 当前位(d位)是（0和1）的数字有多少个</span><br>        <span class="hljs-comment">// count[i] 当前位(d位)是（0~i）的数字有多少个</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(radix)</span></span>;<br>        <span class="hljs-keyword">for</span> (i = L; i &lt;= R; i++)<br>        &#123;<br>            j = <span class="hljs-built_in">getDigit</span>(arr[i], d);<br>            <span class="hljs-comment">// 词频数组</span><br>            count[j]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; radix; i++)<br>        &#123;<br>            <span class="hljs-comment">// 前缀和数组</span><br>            count[i] = count[i] + count[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = R; i &gt;= L; i--)<br>        &#123;<br>            j = <span class="hljs-built_in">getDigit</span>(arr[i], d);<br>            <span class="hljs-comment">// 词频-1作为index放到临时数组bucket里面，每次区分出一个进制位的排序结果分区</span><br>            <span class="hljs-comment">// 至于为什么要从R向L遍历，主要是为了保证排序结果的稳定性</span><br>            bucket[count[j] - <span class="hljs-number">1</span>] = arr[i];<br>            count[j]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = L, j = <span class="hljs-number">0</span>; i &lt;= R; i++, j++)<br>        &#123;<br>            arr[i] = bucket[j];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// only for no-negative value</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">radixSort</span>(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-built_in">maxbits</span>(arr));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试机考题目</title>
    <link href="/2023/09/17/%E9%9D%A2%E8%AF%95%E6%9C%BA%E8%80%83%E9%A2%98%E7%9B%AE/"/>
    <url>/2023/09/17/%E9%9D%A2%E8%AF%95%E6%9C%BA%E8%80%83%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="判断那些会编译报错，阐述原因"><a href="#判断那些会编译报错，阐述原因" class="headerlink" title="判断那些会编译报错，阐述原因"></a>判断那些会编译报错，阐述原因</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *a = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">// error: invalid conversion from &#x27;const char*&#x27; to &#x27;char*&#x27; [-fpermissive]</span><br><span class="hljs-comment">// char *const b = a;</span><br><span class="hljs-comment">// warning: ISO C++ forbids converting a string constant to &#x27;char*&#x27; [-Wwrite-strings]</span><br><span class="hljs-type">char</span> *<span class="hljs-type">const</span> b = <span class="hljs-string">&quot;anything&quot;</span>;<br>a = <span class="hljs-string">&quot;something&quot;</span>;<br><span class="hljs-comment">// error: assignment of read-only variable &#x27;b&#x27;</span><br><span class="hljs-comment">// b = &quot;anything&quot;;</span><br></code></pre></td></tr></table></figure><h2 id="分析下面这段代码的输出结果"><a href="#分析下面这段代码的输出结果" class="headerlink" title="分析下面这段代码的输出结果"></a>分析下面这段代码的输出结果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span><br>&#123;<br>    <span class="hljs-built_in">X</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X &amp;)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;3&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">X</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;4&quot;</span>;<br>    &#125;<br>&#125; object;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 调用复制构造函数</span><br>    <span class="hljs-function">X <span class="hljs-title">val</span><span class="hljs-params">(object)</span></span>;<br>    <span class="hljs-comment">// 调用默认构造函数</span><br>    <span class="hljs-built_in">X</span> ();<br>    <span class="hljs-comment">// 上面默认构造执行完之后立刻进行析构了，因为变量名不存在</span><br>    <span class="hljs-comment">// X *ptr = new X();</span><br>    <span class="hljs-comment">// 调用默认构造函数，对象名为 obj</span><br>    <span class="hljs-built_in">X</span> (obj);<br>    <span class="hljs-comment">// 调用默认构造函数，对象名为局部的 object</span><br>    <span class="hljs-built_in">X</span> (object);<br>    object.<span class="hljs-built_in">f</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为 <code>13121142222</code> </p><h3 id="“直接初始化”或“函数风格的初始化”"><a href="#“直接初始化”或“函数风格的初始化”" class="headerlink" title="“直接初始化”或“函数风格的初始化”"></a>“直接初始化”或“函数风格的初始化”</h3><p>在 C++ 中，我们可以使用“直接初始化”或“函数风格的初始化”来创建和初始化对象。这种初始化方式使用一对圆括号描述类型和初始值，并且不需要使用等号。</p><p>例如，我们可以使用以下代码行来创建和初始化一个整数变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用 int 作为类型名，使用 i 作为变量名，然后将初始值 42 放在圆括号中。这种形式的初始化可以与其他语言中的构造函数调用方式相对应。</p><p>类也可以使用这种初始化方式。如果有一个名为 MyClass 的类，我们可以使用以下代码行来创建和初始化一个 MyClass 类型的对象：</p><p>cpp<br>MyClass obj(“Hello World”);<br>在这个例子中，我们使用 MyClass 作为类型名，使用 obj 作为变量名，然后将初始值 “Hello World” 放在圆括号中。这将调用 MyClass 的带有一个字符串参数的构造函数来创建一个新的 MyClass 对象。</p><p>需要注意的是，直接初始化与<code>括号初始化（braced initialization）</code>有所不同，后者使用了一对花括号 {} 来包围要初始化的值。括号初始化在 C++11 中引入，可以用于静态数组和类类型的聚合体。</p><p>总的来说，“直接初始化”或“函数风格的初始化”是 C++ 中创建和初始化对象的一种简洁方式，可以帮助我们更容易地编写代码并减少错误。</p><h2 id="下面的两行代码都能正常执行-？？？"><a href="#下面的两行代码都能正常执行-？？？" class="headerlink" title="下面的两行代码都能正常执行 ？？？"></a>下面的两行代码都能正常执行 ？？？</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">endl</span>(cout);<br><span class="hljs-keyword">operator</span>&lt;&lt;(std::cout, <span class="hljs-string">&quot;测试\n &quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// \ddd1到3位八进制数所代表的任意字符三位八进制</span><br><span class="hljs-comment">// \xhh十六进制所代表的任意字符十六进制</span><br><span class="hljs-comment">// char *pStr = &quot;\032&quot;;printf(&quot;%d.\n&quot;, pStr[0]);printf(&quot;strlen(pStr) = %d\n&quot;, strlen(pStr));</span><br><span class="hljs-comment">// char *pStr = &quot;\x01234561a\032&quot;;printf(&quot;%d.\n&quot;, pStr[1]);printf(&quot;strlen(pStr) = %d\n&quot;, strlen(pStr));</span><br><span class="hljs-comment">// \x78988881a 相当于 \x1a, 因为 7898888 都是16进制的表示；所以如果想要 \x 停止转义，必须在要在中间加入</span><br><span class="hljs-comment">// 其他字符，如 &quot;\x7h8988881a&quot; ，这样就只会转义 \x7 为一个字符</span><br><span class="hljs-comment">// char *pStr = &quot;\x78988881a&quot;;printf(&quot;%d.\n&quot;, pStr[0]);printf(&quot;strlen(pStr) = %d\n&quot;, strlen(pStr));</span><br><span class="hljs-comment">// char *pStr = &quot;\032123&quot;;printf(&quot;%d.\n&quot;, pStr[1]);printf(&quot;strlen(pStr) = %d\n&quot;, strlen(pStr));</span><br></code></pre></td></tr></table></figure><p>上面代码的输出结果分别为<br>26.<br>strlen(pStr) &#x3D; 1<br>26.<br>strlen(pStr) &#x3D; 2<br>26.<br>strlen(pStr) &#x3D; 1<br>49.<br>strlen(pStr) &#x3D; 4</p><p>这里输出的 49 是1的 ASCII，\032 是26.</p><h2 id="分析这段代码的输出结果"><a href="#分析这段代码的输出结果" class="headerlink" title="分析这段代码的输出结果"></a>分析这段代码的输出结果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)(&amp;a + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %d\n&quot;</span>, *(a + <span class="hljs-number">1</span>), *(p - <span class="hljs-number">2</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果 2, 5</p><h2 id="32位设备下，下面哪个程序输出值最大"><a href="#32位设备下，下面哪个程序输出值最大" class="headerlink" title="32位设备下，下面哪个程序输出值最大?"></a>32位设备下，下面哪个程序输出值最大?</h2><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">number</span> &#123; <span class="hljs-type">char</span> a; <span class="hljs-type">int</span> b; <span class="hljs-type">short</span> <span class="hljs-type">int</span> c; &#125;; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n &quot;</span>, <span class="hljs-built_in">sizeof</span>(number)); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">number</span> &#123; <span class="hljs-type">int</span> b; <span class="hljs-type">long</span> <span class="hljs-type">int</span> c; &#125;; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(number)); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">number</span> &#123; <span class="hljs-type">char</span> a; <span class="hljs-type">char</span> b; <span class="hljs-type">short</span> <span class="hljs-type">int</span> c; <span class="hljs-type">char</span> d; &#125;; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(number)); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">number</span> &#123; <span class="hljs-type">char</span> a; <span class="hljs-type">char</span> b; <span class="hljs-type">int</span> c; <span class="hljs-type">char</span> d; &#125;; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(number)); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-keyword">union</span> <span class="hljs-title class_">number</span> &#123; <span class="hljs-type">long</span> <span class="hljs-type">int</span> a; <span class="hljs-type">int</span> b; <span class="hljs-type">char</span> c; <span class="hljs-type">short</span> <span class="hljs-type">int</span> d; &#125;; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(number));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br></code></pre></td></tr></table></figure><p>12<br>8<br>6<br>12<br>4</p><h4 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h4><p>在没有#pragma pack这个宏的声明下，遵循下面三个原则：</p><p>1、第一个成员的首地址为0.</p><p>2、每个成员的首地址是自身大小的整数倍</p><p>3、结构体的总大小，为其成员中所含最大类型的整数倍。</p><ul><li>数据类型自身的对齐值： 对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节；</li><li>结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值；</li><li>指定对齐值：#pragma pack (value)时的指定对齐值value，32位机器默认为4,64位机器默认为8；</li><li>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">number</span><br>&#123;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> c;<br>    <span class="hljs-type">char</span> d;<br>    <span class="hljs-comment">// short int e;</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_st_struct2</span><br>&#123;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-type">short</span> b;<br>&#125; st_struct2;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">test</span><br>&#123;<br>   <span class="hljs-type">char</span> a : <span class="hljs-number">7</span>;<br>   <span class="hljs-type">int</span> b : <span class="hljs-number">11</span>;<br>   <span class="hljs-type">int</span> c : <span class="hljs-number">22</span>;<br><span class="hljs-comment">//    int c : 10;</span><br>   <span class="hljs-type">int</span> d : <span class="hljs-number">11</span>;<br><span class="hljs-comment">//    int d : 10;</span><br>   <span class="hljs-type">char</span> index;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> number));<br>    <span class="hljs-type">int</span> offset = <span class="hljs-built_in">offsetof</span>(<span class="hljs-keyword">struct</span> number, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Offset of member &#x27;b&#x27;: %zu\n&quot;</span>, offset);<br>    offset = <span class="hljs-built_in">offsetof</span>(<span class="hljs-keyword">struct</span> number, c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Offset of member &#x27;c&#x27;: %zu\n&quot;</span>, offset);<br>    offset = <span class="hljs-built_in">offsetof</span>(<span class="hljs-keyword">struct</span> number, d);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Offset of member &#x27;d&#x27;: %zu\n&quot;</span>, offset);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(st_struct2));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> test));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分析这段代码的输出结果-1"><a href="#分析这段代码的输出结果-1" class="headerlink" title="分析这段代码的输出结果"></a>分析这段代码的输出结果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a = []()&#123; <span class="hljs-type">static</span> <span class="hljs-type">int</span> b = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> b++; &#125;())</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>();<br>    <span class="hljs-built_in">f</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：12</p><h2 id="判断字符串的长度-转义字符的使用"><a href="#判断字符串的长度-转义字符的使用" class="headerlink" title="判断字符串的长度&amp;转义字符的使用"></a>判断字符串的长度&amp;转义字符的使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// warning: octal escape sequence out of range</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;\\a\520\0end&quot;</span>;<br>cout &lt;&lt; <span class="hljs-built_in">strlen</span>(str) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(str) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>3<br>8</p><h2 id="判断下面代码的输出结果"><a href="#判断下面代码的输出结果" class="headerlink" title="判断下面代码的输出结果"></a>判断下面代码的输出结果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A Construct&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">func_init</span>();<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A Destruct&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">func_deinit</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;this is A func_init&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func_deinit</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;this is A func_deinit&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B Construct&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">func_init</span>();<br>    &#125;<br>    ~<span class="hljs-built_in">B</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;B Destruct&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">func_deinit</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_init</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;this is B func_init&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_deinit</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;this is B func_deinit&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><p>A Construct<br>this is A func_init<br>B Construct<br>this is B func_init<br>B Destruct<br>this is B func_deinit<br>A Destruct<br>this is A func_deinit</p><h2 id="与192-168-1-110-27属于同一个子网的主机地址"><a href="#与192-168-1-110-27属于同一个子网的主机地址" class="headerlink" title="与192.168.1.110&#x2F;27属于同一个子网的主机地址"></a>与192.168.1.110&#x2F;27属于同一个子网的主机地址</h2><p>根据给定的IPv4地址<code>192.168.1.110</code>和子网掩码<code>/27</code>，我们可以确定网络的范围。在IPv4中，子网掩码用于划分IP地址中的网络部分和主机部分。</p><p>对于给定的子网掩码<code>/27</code>，它表示前27位是网络部分，剩下的5位是主机部分。换算为二进制，子网掩码为<code>11111111.11111111.11111111.11100000</code>。</p><p>将IP地址192.168.1.110和子网掩码进行按位与操作，可以得到网络地址：192.168.1.96。因此，与192.168.1.110&#x2F;27属于同一个子网的主机地址范围是从 <code>[192.168.1.97, 192.168.1.126]</code></p><p>tip: 110 的二进制是 0110 1110，前三位是 011，即 0x60&#x3D;96，0x7F&#x3D;127</p><ul><li>子网掩码：255.255.255.224</li><li>192.168.1.96          网段</li><li>192.168.1.127           广播段</li><li>192.168.1.97 - 192.168.1.126   IP地址</li></ul><h2 id="使用基数排序对十进制正整数数据序列43-231-96-190-239进行升序排序，低位优先，堆数为10，排序过程中可能的中间序列为"><a href="#使用基数排序对十进制正整数数据序列43-231-96-190-239进行升序排序，低位优先，堆数为10，排序过程中可能的中间序列为" class="headerlink" title="使用基数排序对十进制正整数数据序列43,231,96,190,239进行升序排序，低位优先，堆数为10，排序过程中可能的中间序列为"></a>使用基数排序对十进制正整数数据序列43,231,96,190,239进行升序排序，低位优先，堆数为10，排序过程中可能的中间序列为</h2><p>43,231,96,190,239 -&gt; 190,231,43,96,239 -&gt; 231,239,43,190,96 -&gt; 43,96,190,231,239</p><h2 id="甲、乙、丙、丁、戊、己六人进行兵乓球比赛，采用单循环制。现在知道-甲、乙、丙、丁、戊五人已经分别赛过5、4、3、2、1场。问-这时己已经赛过几场"><a href="#甲、乙、丙、丁、戊、己六人进行兵乓球比赛，采用单循环制。现在知道-甲、乙、丙、丁、戊五人已经分别赛过5、4、3、2、1场。问-这时己已经赛过几场" class="headerlink" title="甲、乙、丙、丁、戊、己六人进行兵乓球比赛，采用单循环制。现在知道:甲、乙、丙、丁、戊五人已经分别赛过5、4、3、2、1场。问:这时己已经赛过几场"></a>甲、乙、丙、丁、戊、己六人进行兵乓球比赛，采用单循环制。现在知道:甲、乙、丙、丁、戊五人已经分别赛过5、4、3、2、1场。问:这时己已经赛过几场</h2><p>模拟：</p><p>甲:5    0<br>乙:4    3   0<br>丙:3    2   1   0<br>丁:2    1   0   0<br>戊:1    0   0   0<br>己:x    x-1 x-2 x-3</p><p>5+3+1&#x3D;9</p><p>所以现在已经进行了<code>9</code>场比赛</p><h2 id="在没有秒表统计的前提下，如果要从25马中选出跑得最快的3匹，每次只能有5匹马同时跑，最少要比赛多少次，才能确保得出结果-请给出推演过程，直接给出答案的不得分。"><a href="#在没有秒表统计的前提下，如果要从25马中选出跑得最快的3匹，每次只能有5匹马同时跑，最少要比赛多少次，才能确保得出结果-请给出推演过程，直接给出答案的不得分。" class="headerlink" title="在没有秒表统计的前提下，如果要从25马中选出跑得最快的3匹，每次只能有5匹马同时跑，最少要比赛多少次，才能确保得出结果? (请给出推演过程，直接给出答案的不得分。)"></a>在没有秒表统计的前提下，如果要从25马中选出跑得最快的3匹，每次只能有5匹马同时跑，最少要比赛多少次，才能确保得出结果? (请给出推演过程，直接给出答案的不得分。)</h2><p>25匹马看成25个点，每次比赛在参赛的5匹马之间引入4条有向边，1-&gt;2-&gt;3-&gt;4-&gt;5，数字表示参赛马的成绩排名。这样最后能形成一个有向无环图, 我们需要得到的是前三名的节点a, b, c, 其中a-&gt;b-&gt;c, 并且c是剩余节点的祖先。六次比赛（分5组各自比赛，之后后每组的第一名比赛）之后，所有的节点已经连成了一个二叉堆，根节点是第一名。只需要让左右子堆的顶点和它们的子节点一起再比一次，就能决出2，3名。</p><p><img src="%E8%B5%9B%E9%A9%AC%E6%AF%94%E8%B5%9B.png" alt="赛马比赛"></p><h2 id="xy，mn各表示一个两位数，若xy-mn-119，则x-y-m-n"><a href="#xy，mn各表示一个两位数，若xy-mn-119，则x-y-m-n" class="headerlink" title="xy，mn各表示一个两位数，若xy+mn&#x3D;119，则x+y+m+n&#x3D;"></a>xy，mn各表示一个两位数，若xy+mn&#x3D;119，则x+y+m+n&#x3D;</h2><p>y+n 必为9，x+m 则为11<br>20</p><h2 id="分析下面这段代码的运行结果"><a href="#分析下面这段代码的运行结果" class="headerlink" title="分析下面这段代码的运行结果"></a>分析下面这段代码的运行结果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;from Base&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-comment">// 这里如果不加 virtual 修饰的话，就会导致 delete base 只调用了基类的析构函数</span><br>    <span class="hljs-comment">// 而没有调用子类的析构函数，导致资源释放不彻底</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123; <span class="hljs-built_in">method</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">baseMethod</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">method</span>(); &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;construct A&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;from A&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; <span class="hljs-built_in">method</span>(); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base *base = <span class="hljs-keyword">new</span> A;<br>    <span class="hljs-comment">// base-&gt;baseMethod();</span><br><br>    <span class="hljs-keyword">delete</span> base;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于linux内存空间"><a href="#关于linux内存空间" class="headerlink" title="关于linux内存空间"></a>关于linux内存空间</h2><p>A、内核空间和用户空间都属于虚拟内存空间：<br>在现代操作系统中，使用虚拟内存的概念将内存空间划分为内核空间和用户空间。虚拟内存使得每个进程都有自己独立的地址空间，从而提供了更高的安全性和隔离性。内核空间是保留给操作系统内核使用的区域，包含了操作系统的代码和数据结构。用户空间是给应用程序和用户代码使用的区域。</p><p>B、内核空间存放的是内核的代码和数据，用户空间存放的是用户的代码和数据：<br>内核空间是操作系统内核运行的地方，其中保存了内核的代码和数据结构，用于管理系统资源和提供各种服务。用户空间是给应用程序和用户代码运行的地方，其中保存了用户的代码和数据，包括应用程序的逻辑、变量、堆栈等。</p><p>C、每个进程有4G的独立内存空间，这4G内存空间相对其他进程都是不可见的：<br>每个进程在虚拟内存中都有自己独立的4GB内存空间（在32位系统中），这是由于操作系统使用了分页机制进行地址映射。不同进程的地址空间彼此隔离，一个进程无法直接访问另一个进程的内存。这种隔离性确保了每个进程的独立性和安全性。</p><p>D、每个进程都可以通过系统调用进入内核，内核为系统中的所有进程共享：<br>进程可以通过系统调用（例如读写文件、创建进程等）进入内核执行特权操作。内核是为系统中的所有进程提供服务和资源管理的关键部分。虽然内核是共享的，但内核通过进程上下文切换来确保不同进程之间的隔离和资源互斥，避免了冲突和干扰。</p><h2 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">4</span>;<br>a += a * a &lt;&lt; <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<br>cout &lt;&lt; a &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>根据C++中运算符的优先级和结合性规则，表达式a +&#x3D; a * a &lt;&lt; 1 + 2的计算顺序如下：</p><ol><li>首先计算 a * a ，得到16。</li><li>然后计算 1 + 2 ，得到3。</li><li>接着计算 16 &lt;&lt; 3 ，即将16的二进制表示向左移动3位，并在右侧添加零来填充，得到128。</li><li>最后计算 a +&#x3D; 128 ，即将变量 a 的值加上128，并将结果赋给变量 a。</li></ol><p>所以最终 a&#x3D;132</p><h2 id="分析代码输出结果"><a href="#分析代码输出结果" class="headerlink" title="分析代码输出结果"></a>分析代码输出结果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> a = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>)<span class="hljs-number">200</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，将一个无符号短整型常量200强制转换为字符类型，并将结果赋给变量a。然后使用printf函数以%d的格式打印变量a的值。</p><p>根据C语言的类型转换规则，将无符号短整型constant 200 转换为字符类型(char)时，会进行截断操作。由于char类型通常是一个字节大小，范围为-128到127，因此200在char类型下将被解释为-56。</p><h2 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h2><p>虚拟存储技术（Virtual Memory）是计算机操作系统中的重要概念，它提供了一种将主存（RAM）和辅助存储设备（如硬盘）结合起来使用的方法。使用虚拟存储技术，操作系统可以将主存空间扩展到比实际可用物理内存更大的范围。</p><p>虚拟存储技术的主要目的是使每个程序能够在自己的地址空间中运行，并且互相隔离，从而增加了计算机系统的可靠性和安全性。</p><p>以下是虚拟存储技术的一些关键特点和工作原理：</p><ol><li><p>虚拟地址空间：每个正在运行的程序都有自己的虚拟地址空间，它是一个抽象的地址空间，包含程序代码、数据、堆栈等部分。这个地址空间通常比实际物理内存的大小要大。</p></li><li><p>分页机制：虚拟存储采用了分页机制，将虚拟地址空间划分为大小相等的页面（Page）。物理内存也被划分为与页面大小相同的块，称为物理页框（Physical Page Frame）。</p></li><li><p>页面置换：由于虚拟地址空间比实际可用的物理内存大，不是所有的页面都可以同时放入物理内存中。当程序访问一个虚拟页时，如果该页不在物理内存中，则会触发页面置换算法，将其中一个物理页替换出来，然后将所需的虚拟页加载到该物理页中。</p></li><li><p>页表：为了跟踪虚拟地址到物理地址的映射关系，操作系统维护了一个页表（Page Table），其中记录了每个虚拟页对应的物理页框的地址。</p></li><li><p>页面调度算法：页面调度算法决定了哪些页面会被置换出去以空出物理内存，常见的算法包括最近最少使用算法（LRU）、先进先出算法（FIFO）等。</p></li></ol><p>虚拟存储技术优点包括：</p><ul><li>允许程序拥有比物理内存更大的地址空间，使得可以运行更大规模和复杂度的程序。</li><li>提供了更好的内存管理，允许多个程序同时运行而彼此独立，提高系统的可靠性和安全性。</li><li>允许操作系统使用辅助存储设备作为内存的扩展，缓解了物理内存的限制，并提高了系统的性能。</li></ul><p>总而言之，虚拟存储技术允许操作系统通过一种抽象的机制，为每个程序提供独立的地址空间，使得更多的程序可以运行在有限的物理内存上，并提供了更好的内存管理和保护机制，从而提高了计算机系统的性能和可靠性。</p><h2 id="根据初始关键字序列-19，22，01，38，10-建立的二叉排序树的高度"><a href="#根据初始关键字序列-19，22，01，38，10-建立的二叉排序树的高度" class="headerlink" title="根据初始关键字序列(19，22，01，38，10)建立的二叉排序树的高度"></a>根据初始关键字序列(19，22，01，38，10)建立的二叉排序树的高度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs s">    19<br>01      22<br>  10        38<br></code></pre></td></tr></table></figure><h2 id="判断下面两端代码分别输出多少个-hello-world"><a href="#判断下面两端代码分别输出多少个-hello-world" class="headerlink" title="判断下面两端代码分别输出多少个 hello world"></a>判断下面两端代码分别输出多少个 hello world</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 两个 hello world</span><br>    <span class="hljs-comment">// int x = 0;</span><br>    <span class="hljs-comment">// for (x = 0; x &lt; 2; x++)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     if (fork())</span><br>    <span class="hljs-comment">//     &#123;</span><br>    <span class="hljs-comment">//         printf(&quot;hello world\n&quot;);</span><br>    <span class="hljs-comment">//         sleep(1);</span><br>    <span class="hljs-comment">//         exit(0);</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">// 8个 hello world</span><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">2</span>; x++)<br>    &#123;<br>        fork();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 两个 hello world</span><br>    <span class="hljs-comment">// int x = 0;</span><br>    <span class="hljs-comment">// for (x = 0; x &lt; 2; x++)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     if (fork())</span><br>    <span class="hljs-comment">//     &#123;</span><br>    <span class="hljs-comment">//         printf(&quot;hello world\n&quot;);</span><br>    <span class="hljs-comment">//         sleep(1);</span><br>    <span class="hljs-comment">//         exit(0);</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">// 8个 hello world</span><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello world\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">2</span>; x++)<br>    &#123;<br>        fork();<br>        <span class="hljs-comment">// ssize_t write(int fd, const void *buf, size_t count);</span><br>        <span class="hljs-comment">// 这样是正常写 6个 hello world</span><br>        <span class="hljs-comment">// write(STDOUT_FILENO, str, strlen(str));</span><br>        <span class="hljs-comment">// printf是标准 io，fork在产生子进程的时候，会把父进程的缓冲区也拷贝一遍</span><br>        <span class="hljs-comment">// printf(&quot;hello world\n&quot;);</span><br>        <span class="hljs-comment">// sleep(1);</span><br>    &#125;<br>    <span class="hljs-comment">// sleep(5);</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于fork的一道经典面试题"><a href="#关于fork的一道经典面试题" class="headerlink" title="关于fork的一道经典面试题"></a>关于fork的一道经典面试题</h2><p>这是一道面试题，问程序最终输出几个“-”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        fork();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确答案是8个，关键在于prinf(“-“)只是将字符放到了进程的缓冲区而不输出，而fork在产生子进程的时候，会把父进程的缓冲区也拷贝一遍。如下图所示：</p><p><img src="fork.png" alt="fork"></p><p>如图，一条箭头表示一个进程，箭头边的0 “-“表示此时该进程的输出缓冲区中没有“-”，1 “-”表示有1个。经过fork后，缓冲区被拷贝，而经过一次prinf，则缓冲区中的“-”增加一个，最终当进程结束的时候，将缓冲区的内容输出。</p><p>如果将printf(“-“)换成printf(“-\n”)，或者在printf(“-“)后加一句fflush(stdout),则每次printf的时候就将“-”输出，缓冲区里面不再有东西，这样执行多少次prinf就输出多少次“-”，结果是6次。</p><p>如果将fork()与prinf(“-“)交换位置，变成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>     &#123;<br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>         fork();<br>     &#125;<br>     <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>则流程图如下：</p><p><img src="fork2.png" alt="fork"></p><p>结果仍然是8次，最后的fork也是有起作用的，因为只有在进程结束后才会输出缓冲区的内容。</p><h2 id="自旋锁的机制和底层原理"><a href="#自旋锁的机制和底层原理" class="headerlink" title="自旋锁的机制和底层原理"></a>自旋锁的机制和底层原理</h2><p>自旋锁是一种基本的线程同步机制，用于保护临界区资源以避免并发访问的问题。它的机制和底层原理如下所述：</p><ol><li>机制：</li></ol><ul><li>当一个线程尝试获取自旋锁时，如果锁是可用的（未被其他线程占用），该线程会立即获取锁并进入临界区执行。</li><li>如果锁已经被其他线程占用，那么当前线程将以循环的方式不断尝试获取锁，而不是进入阻塞状态。这个循环被称为自旋，因为线程会在获取锁之前不断地“旋转”。</li></ul><ol start="2"><li>底层原理：</li></ol><ul><li>自旋锁使用原子操作实现，通常通过 CPU 提供的特殊指令，如 test-and-set 或 compare-and-swap 操作来实现。</li><li>当一个线程尝试获取自旋锁时，它会使用原子操作来尝试将锁的状态从“未锁定”改变为“锁定”状态。如果成功获取到锁，则可以进入临界区执行。如果失败，它会继续尝试获取锁，直到成功为止。</li><li>在多核处理器中，每个核心都有自己的缓存，当一个线程尝试获取自旋锁时，它会在自己的缓存中检查锁的状态。如果另一个核心已经修改了锁的状态，那么该线程会通过内存屏障或者缓存一致性协议来保持缓存的一致性，以确保能够正确地检测到锁的状态变化。</li></ul><p>需要注意的是，自旋锁适用于临界区很小且锁被占用时间短暂的情况。如果临界区很大或者锁的占用时间较长，使用自旋锁可能会导致线程间的竞争，浪费大量的 CPU 时间。在这种情况下，更适合使用其他的线程同步机制，如互斥锁（mutex）或信号量（semaphore）来避免资源竞争和提高性能。</p><h2 id="互斥锁的机制和底层原理"><a href="#互斥锁的机制和底层原理" class="headerlink" title="互斥锁的机制和底层原理"></a>互斥锁的机制和底层原理</h2><p>互斥锁（Mutex）是一种常用的线程同步机制，用于保护临界区资源的并发访问。它的机制和底层原理如下所述：</p><ol><li>机制：</li></ol><ul><li>互斥锁有两个状态：锁定（locked）和未锁定（unlocked）。</li><li>当一个线程尝试获取互斥锁时，如果锁是未锁定状态，该线程会获取锁并进入临界区执行。</li><li>如果锁已经被其他线程锁定，那么当前线程将被阻塞，直到锁被释放为止。多个线程可能会排队等待同一个互斥锁。</li></ul><ol start="2"><li>底层原理：</li></ol><ul><li>互斥锁通常使用原子操作和操作系统的支持来实现。</li><li>原子操作用于确保对互斥锁状态的修改是原子的，即不会被其他线程中断。</li><li>操作系统提供了一些底层同步原语，如 Compare-and-Swap（CAS）、Test-and-Set、Fetch-and-Add（FAA）等，用于实现互斥锁的原子操作。</li><li>当一个线程尝试获取互斥锁时，它会尝试使用原子操作将锁状态从未锁定改变为锁定状态。如果成功获取到锁，则可以进入临界区执行。如果失败，该线程会被阻塞，直到锁被释放。</li><li>当线程释放互斥锁时，它会将锁的状态设置为未锁定，这样其他等待获取锁的线程就有机会获取到锁并进入临界区。</li></ul><p>需要注意的是，互斥锁能够保证临界区资源的独占访问，避免了竞态条件（Race Condition）的发生。但过多地使用互斥锁可能导致线程间频繁地切换和阻塞，降低系统性能。因此，在设计并发程序时，需要合理选择互斥锁的粒度，并考虑使用其他同步机制，如读写锁（Read-Write Lock）或无锁数据结构，以提高并发性能。</p><h2 id="介绍一下线程池"><a href="#介绍一下线程池" class="headerlink" title="介绍一下线程池"></a>介绍一下线程池</h2><p>线程池（Thread Pool）是一种用于管理和复用线程的并发编程技术。它由线程池管理器、工作队列和一组工作线程组成。线程池的主要目的是优化线程的创建、销毁和调度过程，以提高系统的性能和资源利用率。</p><p>线程池的工作原理如下：</p><ol><li>创建线程池：</li></ol><ul><li>在应用程序初始化阶段，创建一个固定数量的工作线程池。</li><li>线程池管理器会创建并启动指定数量的线程，并将它们置于等待状态，准备接受任务。</li></ul><ol start="2"><li>提交任务：</li></ol><ul><li>当应用程序需要执行一个任务时，可以将任务提交给线程池。</li><li>任务被添加到线程池的工作队列中，等待执行。</li></ul><ol start="3"><li>执行任务：</li></ol><ul><li>工作线程从工作队列中取出任务进行执行。</li><li>线程池会自动分配任务给空闲的工作线程，避免了频繁地创建和销毁线程的开销。</li></ul><ol start="4"><li>处理完成：</li></ol><ul><li>当一个任务被执行完成后，工作线程会返回线程池，并继续从工作队列中获取新任务执行。</li><li>线程池管理器会根据实际情况调整线程的数量，可以增加或减少工作线程的数量。</li></ul><p>线程池的优点：</p><ul><li>提高性能和资源利用率：通过复用线程、避免频繁创建和销毁线程，降低了线程创建和上下文切换的开销，提高了系统的性能和资源利用率。</li><li>控制并发度：线程池可以限制同时执行的任务数量，避免过多的并发导致系统资源耗尽。</li><li>更好的管理和监控：线程池提供了监控和管理工具，可以统计线程池的运行状态、异常情况等。</li></ul><p>需要注意的是，合理设置线程池的大小和参数是很重要的，过小的线程池可能无法满足并发需求，而过大的线程池可能会导致资源竞争和性能下降。因此，在使用线程池时，需要仔细评估任务的特性和系统的负载，进行适当的配置和调优。</p><h2 id="shared-ptr-循环引用的问题"><a href="#shared-ptr-循环引用的问题" class="headerlink" title="shared_ptr 循环引用的问题"></a>shared_ptr 循环引用的问题</h2><p>shared_ptr是C++中智能指针的一种类型，用于管理动态分配的对象。它使用引用计数来跟踪指向对象的指针数量，并在没有任何指针引用时自动删除对象。</p><p>然而，使用shared_ptr时，可能会出现循环引用的问题，也称为循环依赖。循环引用指的是两个或多个对象在彼此之间相互持有shared_ptr的情况，导致它们的引用计数永远无法达到0，对象也无法被正确地释放。</p><p>这种情况通常发生在对象之间存在双向关联的情形下。例如，对象A拥有shared_ptr指向对象B，同时对象B也拥有shared_ptr指向对象A。这样，即使没有其他外部引用，A和B的引用计数也永远不会变为0，导致它们占用的内存无法释放。</p><p>为了解决shared_ptr的循环引用问题，可以采用weak_ptr来打破循环依赖。weak_ptr是对shared_ptr的一种弱引用，不会增加对象的引用计数。可以通过将对象之间的循环引用中的某些指针改为weak_ptr来减少引用计数，从而使对象能够在没有其他强引用时被正确释放。</p><p>使用weak_ptr时，需要在使用前先将其转换为shared_ptr，并检查对象是否仍然有效。这可以通过调用weak_ptr的lock()方法来实现。如果对象已被释放或无效，lock()将返回一个空的shared_ptr。</p><p>总的来说，当使用shared_ptr时，需要小心处理循环引用问题，以确保对象能够正确地释放，避免内存泄漏。通过使用weak_ptr来打破循环依赖，可以解决shared_ptr的循环引用问题。</p><h2 id="new-delete-和-malloc-free的异同"><a href="#new-delete-和-malloc-free的异同" class="headerlink" title="new&#x2F;delete 和 malloc&#x2F;free的异同"></a>new&#x2F;delete 和 malloc&#x2F;free的异同</h2><p>new&#x2F;delete和malloc&#x2F;free是用于在C++和C语言中进行动态内存分配和释放的一对对应操作。</p><p>异同点如下：</p><ol><li><p>语法和类型：new和delete是C++关键字，而malloc和free是C标准库函数。因此，new和delete在C++中使用，malloc和free在C语言中使用。</p></li><li><p>类型安全性：new和delete在语法上是与类型相关的操作符，能够自动计算所需的内存大小并执行类型转换。它们还会调用构造函数和析构函数来初始化和销毁对象。而malloc和free则是通用的内存分配和释放函数，无法自动执行类型转换和调用构造&#x2F;析构函数。因此，在C++中，如果需要动态分配和释放对象，建议使用new和delete，以确保类型安全和正确的对象构造和析构。</p></li><li><p>内存分配方式：new和delete操作符使用的是C++的内存管理机制，可以直接调用全局的operator new和operator delete函数来执行内存分配和释放。而malloc和free函数是C语言中的内存分配函数，使用堆来分配内存。</p></li><li><p>大小信息：malloc函数需要传递所需内存块的大小，以字节为单位。而new操作符根据所需对象的类型自动计算大小。</p></li><li><p>返回值：new操作符返回指向分配的对象的指针，而malloc函数返回一个void指针。需要将其显式转换为适当的指针类型。</p></li><li><p>异常处理：new操作符在内存分配失败时会抛出std::bad_alloc异常，而malloc函数在分配失败时返回NULL。因此，在使用new时，我们可以通过捕获异常来处理内存分配失败的情况，而malloc则需要手动检查返回值是否为NULL。</p></li></ol><p>综上所述，new&#x2F;delete和malloc&#x2F;free在功能和用法上有一些区别，尤其是对于C++中的对象分配和释放，建议使用new和delete来确保类型安全和正确的构造&#x2F;析构行为。</p><h2 id="判断-ABCD-的析构顺序"><a href="#判断-ABCD-的析构顺序" class="headerlink" title="判断 ABCD 的析构顺序"></a>判断 ABCD 的析构顺序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-comment">/* args */</span>)&#123;&#125;;<br>    ~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A des&quot;</span> &lt;&lt; endl; &#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(<span class="hljs-comment">/* args */</span>)&#123;&#125;;<br>    ~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B des&quot;</span> &lt;&lt; endl; &#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">C</span>(<span class="hljs-comment">/* args */</span>)&#123;&#125;;<br>    ~<span class="hljs-built_in">C</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;C des&quot;</span> &lt;&lt; endl; &#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">D</span>(<span class="hljs-comment">/* args */</span>)&#123;&#125;;<br>    ~<span class="hljs-built_in">D</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;D des&quot;</span> &lt;&lt; endl; &#125;;<br>&#125;;<br><br>C c;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A *pa = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br>    B b;<br>    <span class="hljs-type">static</span> D d;<br>    <span class="hljs-keyword">delete</span> pa;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>析构顺序为 ABDC</p><h2 id="介绍一下锁"><a href="#介绍一下锁" class="headerlink" title="介绍一下锁"></a>介绍一下锁</h2><p>锁（Lock）是计算机科学中的一种同步机制，用于控制对共享资源的访问。当多个线程或进程试图同时访问共享资源时，锁能够确保每个线程或进程都能够安全地访问共享资源，从而避免竞态条件等问题的发生。</p><p>以下是几种常见的锁类型：</p><ol><li>互斥锁（Mutex）：</li></ol><ul><li>互斥锁是最基本的一种锁。</li><li>只有一个线程可以获得互斥锁，其他线程必须等待该线程释放锁。</li><li>适用于需要独占访问共享资源的情况。</li></ul><ol start="2"><li>读写锁（Read-Write Lock）：</li></ol><ul><li>读写锁允许多个线程同时读取共享资源，但只允许一个线程进行写操作。</li><li>当没有线程进行写操作时，多个线程可以同时获取读锁。</li><li>适用于读操作远远超过写操作的场景，可以提高并发性能。</li></ul><ol start="3"><li>自旋锁（Spin Lock）：</li></ol><ul><li>自旋锁是一种忙等待的锁，线程会一直循环等待直到获得锁。</li><li>适用于对共享资源的访问时间非常短暂的场合，避免线程上下文切换的开销。</li></ul><ol start="4"><li>条件变量（Condition Variable）：</li></ol><ul><li>条件变量是一种同步机制，用于线程之间的通信。</li><li>当一个线程需要等待某个条件满足时，可以通过条件变量将自己挂起，等待其他线程发送信号或广播来唤醒它。</li></ul><ol start="5"><li>信号量（Semaphore）：</li></ol><ul><li>信号量是一种同步机制，用于控制对共享资源的访问。</li><li>信号量可以用来实现互斥锁和读写锁等功能，同时也可以实现进程之间的同步和互斥。</li></ul><p>使用锁能够有效地避免多线程程序中的数据竞争和并发访问的问题，确保数据的正确性和线程的安全性。但需要注意，在使用锁时要避免死锁（Deadlock）和饥饿（Starvation）等问题，合理设计锁的粒度和使用方式，以提高程序的性能和可靠性。</p><h2 id="什么是栈溢出？怎么避免栈溢出"><a href="#什么是栈溢出？怎么避免栈溢出" class="headerlink" title="什么是栈溢出？怎么避免栈溢出"></a>什么是栈溢出？怎么避免栈溢出</h2><p>栈溢出（Stack Overflow）是指当程序在执行过程中，使用了过多的栈空间，超出了栈的大小限制，导致数据溢出到其他内存区域。</p><p>在计算机中，每个进程都有一个用于存储局部变量、函数调用和其他临时数据的内存区域，称为栈（Stack）。栈是一种后进先出（LIFO）的数据结构，由一系列内存块组成，用于存储函数调用的上下文信息。</p><p>当一个函数被调用时，它的参数、局部变量和返回地址等数据会被压入栈中。而当函数执行完成后，栈上的数据会被弹出，控制权返回给调用者。</p><p>栈溢出通常发生在以下情况下：</p><ol><li>递归调用：</li></ol><ul><li>如果递归调用没有正确终止条件或递归深度过大，每次递归调用都会将数据压入栈中，导致栈空间耗尽。</li></ul><ol start="2"><li>局部变量过多或过大：</li></ol><ul><li>当函数中定义了太多的局部变量，或某个局部变量占用的内存空间过大，都会导致栈的空间不足以容纳这些变量。</li></ul><ol start="3"><li>缓冲区溢出：</li></ol><ul><li>当程序中使用了不安全的输入处理方式，如未对输入进行正确的边界检查，恶意输入数据可能超出预留的缓冲区大小，将多余的数据写入栈中，导致栈溢出。</li></ul><p>栈溢出可能会导致程序异常终止、崩溃或者产生安全漏洞。攻击者可以利用栈溢出漏洞来覆盖函数返回地址，执行恶意代码或实施其他攻击。</p><p>为防止栈溢出，可以采取以下措施：</p><ol><li>合理设计递归算法，确保递归深度不会过大。</li><li>减少函数中的局部变量数量和大小，合理管理内存使用。</li><li>对用户输入进行严格的边界检查和验证，避免缓冲区溢出。</li><li>使用编程语言或框架提供的安全函数和工具，如使用安全的字符串处理函数替代容易造成缓冲区溢出的函数。</li></ol><p>正确地处理栈的使用可以有效预防栈溢出问题，并提高程序的稳定性和安全性。</p><h2 id="设数组S-23-70-62-15-99-50-128-66-48-82-9-136-，采用最低位优先-LSD-基数排序将S排列成升序序列"><a href="#设数组S-23-70-62-15-99-50-128-66-48-82-9-136-，采用最低位优先-LSD-基数排序将S排列成升序序列" class="headerlink" title="设数组S[]=[23,70,62,15,99,50,128,66,48,82,9,136]，采用最低位优先(LSD)基数排序将S排列成升序序列"></a>设数组<code>S[]=[23,70,62,15,99,50,128,66,48,82,9,136]</code>，采用最低位优先(LSD)基数排序将S排列成升序序列</h2><p>首先，我们需要确定最大数字的位数，以确定进行多少次排序。在这个数组中，最大的数字是136，它有3位数。因此，我们需要进行3次排序。</p><p>第一趟排序：<br>按照个位数进行排序，数字范围是0到9。具体操作如下：</p><ul><li>放入桶中：[70, 50], [62, 82], [23], [15], [66, 136], [128, 48], [99, 9]</li></ul><p>第二趟排序：<br>按照十位数进行排序，数字范围是0到9。具体操作如下：</p><ul><li>放入桶中：[9], [15], [23, 128], [136], [48], [50], [62, 66], [70], [82], [99]</li></ul><p>第三趟排序：<br>按照百位数进行排序，数字范围是0到1。具体操作如下：</p><ul><li>放入桶中：[9, 15, 23, 48. 50, 62, 66, 70, 82, 99], [128, 136]</li></ul><p>最终，数组S被排列成升序序列如下：<br>[9, 15, 23, 48, 50, 62, 66, 70, 82, 99, 128, 136]</p><h2 id="在表达式6＋5-3-2＋1-9中，使用栈对表达式进行求值的过程中，当扫描到1时，其对象栈为"><a href="#在表达式6＋5-3-2＋1-9中，使用栈对表达式进行求值的过程中，当扫描到1时，其对象栈为" class="headerlink" title="在表达式6＋5*(3*2＋1)-9中，使用栈对表达式进行求值的过程中，当扫描到1时，其对象栈为()"></a>在表达式6＋5*(3*2＋1)-9中，使用栈对表达式进行求值的过程中，当扫描到1时，其对象栈为()</h2>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp八股文</title>
    <link href="/2023/09/17/cpp%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/2023/09/17/cpp%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>less</title>
    <link href="/2023/08/29/less/"/>
    <url>/2023/08/29/less/</url>
    
    <content type="html"><![CDATA[<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>问题的起源：unordered_map&lt;key, value&gt; 中 key 和 map&lt;key, value&gt; 的 key 都要怎么组织？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Job</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> money; <span class="hljs-comment">// 该工作的报酬</span><br>    <span class="hljs-type">int</span> hard;  <span class="hljs-comment">// 该工作的难度</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Job</span>(<span class="hljs-type">int</span> money, <span class="hljs-type">int</span> hard)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;money = money;<br>        <span class="hljs-keyword">this</span>-&gt;hard = hard;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JobComparator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Job &amp;o1, <span class="hljs-type">const</span> Job &amp;o2)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 难度由小到大；如果报酬一样，报酬由大到小</span><br>        <span class="hljs-keyword">return</span> o1.hard != o2.hard ? (o1.hard &lt; o2.hard) : (o1.money &gt; o2.money);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Job <span class="hljs-title">o1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span>, <span class="hljs-title">o2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span>, <span class="hljs-title">o3</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)</span>, <span class="hljs-title">o4</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span>, <span class="hljs-title">o5</span><span class="hljs-params">(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>)</span></span>;<br>    vector&lt;Job&gt; jobs = &#123;o1, o2, o3, o4, o5&#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sorted by JobComparator()&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">stable_sort</span>(jobs.<span class="hljs-built_in">begin</span>(), jobs.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">JobComparator</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : jobs)<br>    &#123;<br>        cout &lt;&lt; it.hard &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it.money &lt;&lt; endl;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;sorted by lambda&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> Job &amp;o1, <span class="hljs-type">const</span> Job &amp;o2) -&gt; <span class="hljs-type">bool</span><br>    &#123;<br>        <span class="hljs-comment">// 难度由小到大；如果报酬一样，报酬由大到小</span><br>        <span class="hljs-keyword">return</span> o1.hard != o2.hard ? (o1.hard &lt; o2.hard) : (o1.money &gt; o2.money);<br>    &#125;;<br>    <span class="hljs-built_in">stable_sort</span>(jobs.<span class="hljs-built_in">begin</span>(), jobs.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : jobs)<br>    &#123;<br>        cout &lt;&lt; it.hard &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it.money &lt;&lt; endl;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;priority_queue&lt;Job, vector&lt;Job&gt;, JobComparator&gt;&quot;</span> &lt;&lt; endl;<br>    priority_queue&lt;Job, vector&lt;Job&gt;, JobComparator&gt; <span class="hljs-built_in">pq</span>(jobs.<span class="hljs-built_in">begin</span>(), jobs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        Job cur = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; cur.hard &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; cur.money &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">auto</span> plus = [=](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) <span class="hljs-keyword">mutable</span> -&gt; <span class="hljs-type">int</span><br>    &#123;<br>        x++;<br>        <span class="hljs-keyword">return</span> x + y + a + b;<br>    &#125;;<br>    <span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test1</span>();<br>    <span class="hljs-comment">// test2();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++ 语言特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>less</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特化hash</title>
    <link href="/2023/08/29/%E7%89%B9%E5%8C%96hash/"/>
    <url>/2023/08/29/%E7%89%B9%E5%8C%96hash/</url>
    
    <content type="html"><![CDATA[<h2 id="特化hash"><a href="#特化hash" class="headerlink" title="特化hash"></a>特化hash</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 堆上放的是 Node 类型的实例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    string str;<br>    <span class="hljs-type">int</span> times;<br>    <span class="hljs-built_in">Node</span>(string s, <span class="hljs-type">int</span> t) : <span class="hljs-built_in">str</span>(s), <span class="hljs-built_in">times</span>(t) &#123;&#125;<br>    <span class="hljs-built_in">Node</span>() : <span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;&quot;</span>), <span class="hljs-built_in">times</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Node &amp;n) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;str == n.str &amp;&amp; <span class="hljs-keyword">this</span>-&gt;times == n.times;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hashCombine</span><span class="hljs-params">(<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;arg)</span> <span class="hljs-comment">// 真正的hash在这里完成</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 这里虽然也用到了标准库提供的hash函数，但是后面可以添加自己的一些数据（甚至hash&lt;T&gt;()(arg)操作也可以有我们自己来做）</span><br>    <span class="hljs-comment">// 不同用户在这里可以有不同的数，只要能够将原始数据尽可能打乱即可</span><br>    <span class="hljs-comment">// 0x9e3779b9涉及到数学中的黄金比例，实际上并不需要一定是这个数</span><br>    seed ^= <span class="hljs-built_in">hash</span>&lt;T&gt;()(arg) + <span class="hljs-number">0x9e3779b9</span> + (seed &lt;&lt; <span class="hljs-number">6</span>) + (seed &gt;&gt; <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hashValue</span><span class="hljs-params">(<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T &amp;arg)</span> <span class="hljs-comment">// ③递归出口</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">hashCombine</span>(seed, arg);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>... T2&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hashValue</span><span class="hljs-params">(<span class="hljs-type">size_t</span> &amp;seed, <span class="hljs-type">const</span> T1 &amp;arg, <span class="hljs-type">const</span> T2 &amp;...args)</span> <span class="hljs-comment">// ②在这里通过递归逐步拿到所有参数,当args...的大小为1时跳出该递归，接着进入③</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">hashCombine</span>(seed, arg);<br>    <span class="hljs-built_in">hashValue</span>(seed, args...); <span class="hljs-comment">// 递归</span><br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... T&gt;           <span class="hljs-comment">// T为模板参数包，可以代表任意多个类型；args为函数参数包，可以代表任意多个函数参数</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">hashValue</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;...args)</span> <span class="hljs-comment">// ①在这里完成参数的第一次拆分，接着进入②</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">size_t</span> seed = <span class="hljs-number">0</span>;          <span class="hljs-comment">// 种子，以引用方式传递</span><br>    <span class="hljs-built_in">hashValue</span>(seed, args...); <span class="hljs-comment">// args...中为T类型对象中的所有用于hash的数据成员</span><br>    <span class="hljs-keyword">return</span> seed;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hasher</span><br>&#123; <span class="hljs-comment">// hash函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Node &amp;n)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hashValue</span>(n.str, n.times);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TopKRecord</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TopKRecord</span>(<span class="hljs-type">int</span> size)<br>    &#123;<br>        heap.<span class="hljs-built_in">resize</span>(size);<br>        index = <span class="hljs-number">0</span>;<br>    &#125; <br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;Node&gt; heap;<br>    <span class="hljs-comment">// index 表示目前为止堆有多少个元素</span><br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-comment">// 词频表</span><br>    unordered_map&lt;string, Node&gt; strNodeMap;<br>    <span class="hljs-comment">// node 在堆上的下标；如果不在堆上，下标为 index</span><br>    unordered_map&lt;Node, <span class="hljs-type">int</span>, Hasher&gt; nodeIndexMap;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++ 语言特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>heapSort</title>
    <link href="/2023/08/29/heapSort/"/>
    <url>/2023/08/29/heapSort/</url>
    
    <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 停止条件：当前来到头结点或者当前节点不在比它的父节点大</span><br>    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>        index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> heapSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; heapSize)<br>    &#123;<br>        <span class="hljs-comment">// two children choose bigger one</span><br>        <span class="hljs-type">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;<br>        <span class="hljs-comment">// 父和较大孩子之间，谁的值大，把下标给largest</span><br>        largest = arr[largest] &gt; arr[index] ? largest : index;<br>        <span class="hljs-keyword">if</span> (index == largest)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr, largest, index);<br>        index = largest;<br>        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// O(N)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-comment">// O(logN)</span><br>        <span class="hljs-built_in">heapInsert</span>(arr, i);<br>    &#125;<br>    <span class="hljs-type">int</span> heapSize = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">swap</span>(arr, <span class="hljs-number">0</span>, --heapSize);<br>    <span class="hljs-comment">// O(N)</span><br>    <span class="hljs-keyword">while</span> (heapSize &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// O(logN)</span><br>        <span class="hljs-built_in">heapify</span>(arr, <span class="hljs-number">0</span>, heapSize);<br>        <span class="hljs-comment">// O(1)</span><br>        <span class="hljs-built_in">swap</span>(arr, <span class="hljs-number">0</span>, --heapSize);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">3</span>, right = <span class="hljs-number">99</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>    &#123;<br>        arr.<span class="hljs-built_in">push_back</span>((<span class="hljs-type">int</span>)((<span class="hljs-type">float</span>)<span class="hljs-built_in">rand</span>() / RAND_MAX * (right - left + <span class="hljs-number">1</span>) + left));<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : arr)<br>    &#123;<br>        cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-built_in">heapSort</span>(arr);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : arr)<br>    &#123;<br>        cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h2><p>小根堆（Min Heap）是一种堆数据结构，它满足以下两个性质：</p><ol><li><p>父节点的值小于等于其子节点的值。</p><ul><li>对于任意节点 i，父节点的值 arr[i] &lt;&#x3D; arr[2i+1] 和 arr[i] &lt;&#x3D; arr[2i+2]。</li></ul></li><li><p>堆是一个完全二叉树或者可以看作是数组的一种逻辑结构。</p><ul><li>除了最后一层外，其他所有层都是满的，最后一层从左到右连续排列（可能不满）。</li><li>堆可以使用数组来表示，根据父节点和子节点之间的关系，通过一些计算可以在数组中进行快速的定位。</li></ul></li></ol><p>小根堆的性质决定了最小的元素（根节点）位于堆的顶部。这就使得小根堆可以用来解决很多优先级相关的问题，如获取最小值或者按照升序排列元素。</p><p>小根堆的操作包括堆化和插入两个主要过程：</p><ol><li><p>堆化（Heapify）：</p><ul><li>堆化是将一个无序的数组转换为一个满足小根堆性质的堆的过程。</li><li>堆化操作可以分为自顶向下和自底向上两种方式。</li><li>自顶向下（Top-down）堆化是从根节点开始，将当前节点和其子节点进行比较并交换，直到满足小根堆性质。</li><li>自底向上（Bottom-up）堆化是从最后一个非叶子节点开始，将当前节点和其子节点进行比较并交换，直到满足小根堆性质。</li></ul></li><li><p>插入（Insert）：</p><ul><li>插入操作将新元素插入到小根堆的合适位置，并保持小根堆的性质。</li><li>首先，将新元素插入到数组的末尾。</li><li>然后，通过比较新元素与其父节点的值，逐步向上移动元素，直到满足小根堆性质。</li></ul></li></ol><p>小根堆还可以用于优先队列的实现，其中每个元素都有一个优先级，小根堆可以快速找到具有最小优先级的元素。</p><p>堆排序算法也利用小根堆来对元素进行排序。首先，根据输入数组构建一个小根堆；然后，反复从堆顶取出最小元素，并调整堆保持小根堆性质，直到排序完成。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/2023/08/29/KMP/"/>
    <url>/2023/08/29/KMP/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串类算法"><a href="#字符串类算法" class="headerlink" title="字符串类算法"></a>字符串类算法</h1><p>寻找子串、寻找回文字符串（逆序之后寻找子串）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNextArray</span><span class="hljs-params">(string &amp;str, vector&lt;<span class="hljs-type">int</span>&gt; &amp;next)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">length</span>() == <span class="hljs-number">1</span>)<br>    &#123;<br>        next.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    next.<span class="hljs-built_in">resize</span>(str.<span class="hljs-built_in">length</span>());<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; <span class="hljs-comment">// next数组的位置</span><br>    <span class="hljs-type">int</span> cn = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; next.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span> (str[i - <span class="hljs-number">1</span>] == str[cn])<br>        &#123;<br>            next[i++] = ++cn;<br>        &#125;<br>        <span class="hljs-comment">// 当前跳到cn位置的字符，和i-1位置字符配不上</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cn &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            cn = next[cn];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            next[i++] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(string &amp;s, string &amp;m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">length</span>() &lt; <span class="hljs-number">1</span> || s.<span class="hljs-built_in">length</span>() &lt; m.<span class="hljs-built_in">length</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> i1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i2 = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; next;<br>    <span class="hljs-comment">// O(M)</span><br>    <span class="hljs-built_in">getNextArray</span>(m, next);<br>    <span class="hljs-comment">// O(N)</span><br>    <span class="hljs-keyword">while</span> (i1 &lt; s.<span class="hljs-built_in">length</span>() &amp;&amp; i2 &lt; m.<span class="hljs-built_in">length</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s[i1] == m[i2])<br>        &#123;<br>            i1++;<br>            i2++;<br>        &#125;<br>        <span class="hljs-comment">// i2 == 0</span><br>        <span class="hljs-comment">// i2来到0位置，只有0位置为-1</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next[i2] == <span class="hljs-number">-1</span>)<br>        &#123;<br>            i1++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            i2 = next[i2];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// i1越界或者i2越界了</span><br>    <span class="hljs-keyword">return</span> i2 == m.<span class="hljs-built_in">length</span>() ? i1 - i2 : <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s = <span class="hljs-string">&quot;abbztabbxabbg&quot;</span>;<br>    string m = <span class="hljs-string">&quot;abbg&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">KMP</span>(s, m) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test1</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串类算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀树</title>
    <link href="/2023/08/29/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <url>/2023/08/29/%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> pass;<br>    <span class="hljs-type">int</span> end;<br><br>    <span class="hljs-comment">// 当字符种类非常多的时候（例如java中有六万多字符）</span><br>    <span class="hljs-comment">// 这个时候再去采用定长的数组显然不合适</span><br>    <span class="hljs-comment">// 可以采用hashmap来存放字符和node</span><br>    <span class="hljs-comment">// unordered_map&lt;char, shared_ptr&lt;TrieNode&gt;&gt; nexts;</span><br>    vector&lt;shared_ptr&lt;TrieNode&gt;&gt; nexts;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TrieNode</span>()<br>    &#123;<br>        pass = <span class="hljs-number">0</span>;<br>        end = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// nexts[0] == nullptr,  没有走向&#x27;a&#x27;的路</span><br>        <span class="hljs-comment">// nexts[0] != nullptr,  有走向&#x27;a&#x27;的路</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// nexts[25] != nullptr</span><br>        nexts.<span class="hljs-built_in">resize</span>(<span class="hljs-number">26</span>, <span class="hljs-literal">nullptr</span>);<br>    &#125;<br>    ~<span class="hljs-built_in">TrieNode</span>()<br>    &#123;<br>        nexts.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;TrieNode&gt; root;<br>    <span class="hljs-built_in">Trie</span>()<br>    &#123;<br>        root = <span class="hljs-built_in">make_shared</span>&lt;TrieNode&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span></span><br><span class="hljs-function">    </span>&#123;<br>        TrieNode *node = root.<span class="hljs-built_in">get</span>();<br>        node-&gt;pass++;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; word.<span class="hljs-built_in">length</span>(); i++)<br>        &#123;<br>            index = word[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node-&gt;nexts[index] == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                node-&gt;nexts[index] = <span class="hljs-built_in">make_shared</span>&lt;TrieNode&gt;();<br>            &#125;<br>            node = node-&gt;nexts[index].<span class="hljs-built_in">get</span>();<br>            node-&gt;pass++;<br>        &#125;<br>        node-&gt;end++;<br>    &#125;<br><br>    <span class="hljs-comment">// word这个单词之前加入过几次</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span></span><br><span class="hljs-function">    </span>&#123;<br>        TrieNode *node = root.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; word.<span class="hljs-built_in">length</span>(); i++)<br>        &#123;<br>            index = word[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node-&gt;nexts[index] == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            node = node-&gt;nexts[index].<span class="hljs-built_in">get</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;end;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除一个单词</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteWord</span><span class="hljs-params">(string word)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">search</span>(word) != <span class="hljs-number">0</span>)<br>        &#123;<br>            TrieNode *node = root.<span class="hljs-built_in">get</span>();<br>            node-&gt;pass--;<br>            <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; word.<span class="hljs-built_in">length</span>(); i++)<br>            &#123;<br>                index = word[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (--node-&gt;nexts[index].<span class="hljs-built_in">get</span>()-&gt;pass == <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 从当前已知p节点遍历到底去析构</span><br>                    shared_ptr&lt;TrieNode&gt; cur = node-&gt;nexts[index];<br>                    node-&gt;nexts[index].<span class="hljs-built_in">reset</span>();<br>                    node-&gt;nexts[index] = <span class="hljs-literal">nullptr</span>;<br>                    i++;<br>                    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span> &amp;&amp; i &lt; word.<span class="hljs-built_in">length</span>())<br>                    &#123;<br>                        node = cur-&gt;nexts[word[i] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">get</span>();<br>                        node-&gt;nexts[index].<span class="hljs-built_in">reset</span>();<br>                        node-&gt;nexts[index] = <span class="hljs-literal">nullptr</span>;<br>                        cur = cur-&gt;nexts[word[++i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>                    &#125;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                node = node-&gt;nexts[index].<span class="hljs-built_in">get</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prefixNumber</span><span class="hljs-params">(string pre)</span></span><br><span class="hljs-function">    </span>&#123;<br>        TrieNode *node = root.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pre.<span class="hljs-built_in">length</span>(); i++)<br>        &#123;<br>            index = pre[index] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node-&gt;nexts[index] == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            node = node-&gt;nexts[index].<span class="hljs-built_in">get</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;pass;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Trie t;<br>    t.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dijkstra</title>
    <link href="/2023/08/29/Dijkstra/"/>
    <url>/2023/08/29/Dijkstra/</url>
    
    <content type="html"><![CDATA[<h1 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h1><h2 id="Dijkstra算法介绍"><a href="#Dijkstra算法介绍" class="headerlink" title="Dijkstra算法介绍"></a>Dijkstra算法介绍</h2><ul><li>算法特点：</li></ul><p>迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</p><ul><li>算法的思路</li></ul><p>Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] &#x3D; 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。<br>然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，<br>然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。<br>然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。</p><h2 id="Dijkstra算法的代码实现"><a href="#Dijkstra算法的代码实现" class="headerlink" title="Dijkstra算法的代码实现"></a>Dijkstra算法的代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;graph.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function">Node *<span class="hljs-title">getMinDistanceAndUnselectedNode</span><span class="hljs-params">(unordered_map&lt;Node *, <span class="hljs-type">int</span>&gt; &amp;distanceMap, unordered_set&lt;Node *&gt; &amp;selectedNodes)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *minNode = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> minDistance = INT32_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;entry : distanceMap)<br>    &#123;<br>        Node *node = entry.first;<br>        <span class="hljs-type">int</span> distance = entry.second;<br>        <span class="hljs-comment">// 这个点如果已经被“锁定”，是不会去考虑的</span><br>        <span class="hljs-comment">// 只有当前节点没有被锁定，且距离更小我就去更新 minNode</span><br>        <span class="hljs-keyword">if</span> (selectedNodes.<span class="hljs-built_in">find</span>(node) == selectedNodes.<span class="hljs-built_in">end</span>() &amp;&amp; distance &lt; minDistance)<br>        &#123;<br>            minNode = node;<br>            minDistance = distance;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> minNode;<br>&#125;<br><br><span class="hljs-function">unordered_map&lt;Node *, <span class="hljs-type">int</span>&gt; <span class="hljs-title">dijkstra</span><span class="hljs-params">(Node *head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">unordered_map</span>&lt;Node *, <span class="hljs-type">int</span>&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">// 从 head 出发到所有点的最小距离</span><br>    <span class="hljs-comment">// key: 从head出发到达key</span><br>    <span class="hljs-comment">// value: 从head出发到达key的最小距离</span><br>    <span class="hljs-comment">// 如果表中没有某一个节点的数据，则说明head到这个节点的距离为无穷大</span><br>    unordered_map&lt;Node *, <span class="hljs-type">int</span>&gt; distanceMap;<br>    distanceMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(head, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// 已经求过距离的节点，存放在selectedNodes中，以后再也不碰</span><br>    unordered_set&lt;Node *&gt; selectedNodes;<br><br>    <span class="hljs-comment">// Node *minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br>    Node *minNode = head;<br>    <span class="hljs-keyword">while</span> (minNode != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> distance = distanceMap[minNode];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;edge : minNode-&gt;edges)<br>        &#123;<br>            Node *toNode = edge-&gt;to;<br>            <span class="hljs-keyword">if</span> (distanceMap.<span class="hljs-built_in">find</span>(toNode) == distanceMap.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                distanceMap[toNode] = distance + edge-&gt;weight;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                distanceMap[toNode] = <span class="hljs-built_in">min</span>(distanceMap[toNode], distance + edge-&gt;weight);<br>            &#125;<br>        &#125;<br>        selectedNodes.<span class="hljs-built_in">insert</span>(minNode);<br>        minNode = <span class="hljs-built_in">getMinDistanceAndUnselectedNode</span>(distanceMap, selectedNodes);<br>    &#125;<br>    <span class="hljs-keyword">return</span> distanceMap;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; matrix = &#123;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;, <br>    &#123;<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">200</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">200</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">14</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;, <br>    &#123;<span class="hljs-number">14</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">16</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">16</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;&#125;;<br>    shared_ptr&lt;Graph&gt; graph = <span class="hljs-built_in">creatGraph</span>(matrix);<br><br>    unordered_map&lt;Node *, <span class="hljs-type">int</span>&gt; res = <span class="hljs-built_in">dijkstra</span>(graph.<span class="hljs-built_in">get</span>()-&gt;nodes[<span class="hljs-number">1</span>].<span class="hljs-built_in">get</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : res)<br>    &#123;<br>        cout &lt;&lt; it.first-&gt;value &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it.second &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test1</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="另一种实现方式"><a href="#另一种实现方式" class="headerlink" title="另一种实现方式"></a>另一种实现方式</h3><p><code>Dijkstra.h文件的代码</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/************************************************************/</span><br><span class="hljs-comment">/*                程序作者：Willam                          */</span><br><span class="hljs-comment">/*                程序完成时间：2017/3/8                    */</span><br><span class="hljs-comment">/*                有任何问题请联系：2930526477@qq.com       */</span><br><span class="hljs-comment">/************************************************************/</span><br><span class="hljs-comment">//@尽量写出完美的程序</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-comment">//#pragma once是一个比较常用的C/C++杂注，</span><br><span class="hljs-comment">//只要在头文件的最开始加入这条杂注，</span><br><span class="hljs-comment">//就能够保证头文件只被编译一次。</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">本程序是使用Dijkstra算法实现求解最短路径的问题</span><br><span class="hljs-comment">采用的邻接矩阵来存储图</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//记录起点到每个顶点的最短路径的信息</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dis</span> &#123;<br>    string path;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-type">bool</span> visit;<br>    <span class="hljs-built_in">Dis</span>() &#123;<br>        visit = <span class="hljs-literal">false</span>;<br>        value = <span class="hljs-number">0</span>;<br>        path = <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph_DG</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> vexnum;   <span class="hljs-comment">//图的顶点个数</span><br>    <span class="hljs-type">int</span> edge;     <span class="hljs-comment">//图的边数</span><br>    <span class="hljs-type">int</span> **arc;   <span class="hljs-comment">//邻接矩阵</span><br>    Dis * dis;   <span class="hljs-comment">//记录各个顶点最短路径的信息</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">Graph_DG</span>(<span class="hljs-type">int</span> vexnum, <span class="hljs-type">int</span> edge);<br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">Graph_DG</span>();<br>    <span class="hljs-comment">// 判断我们每次输入的的边的信息是否合法</span><br>    <span class="hljs-comment">//顶点从1开始编号</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check_edge_value</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> weight)</span></span>;<br>    <span class="hljs-comment">//创建图</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createGraph</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//打印邻接矩阵</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//求最短路径</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> begin)</span></span>;<br>    <span class="hljs-comment">//打印最短路径</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_path</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>Dijkstra.cpp文件的代码</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Dijkstra.h&quot;</span></span><br><br><span class="hljs-comment">//构造函数</span><br>Graph_DG::<span class="hljs-built_in">Graph_DG</span>(<span class="hljs-type">int</span> vexnum, <span class="hljs-type">int</span> edge) &#123;<br>    <span class="hljs-comment">//初始化顶点数和边数</span><br>    <span class="hljs-keyword">this</span>-&gt;vexnum = vexnum;<br>    <span class="hljs-keyword">this</span>-&gt;edge = edge;<br>    <span class="hljs-comment">//为邻接矩阵开辟空间和赋初值</span><br>    arc = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[<span class="hljs-keyword">this</span>-&gt;vexnum];<br>    dis = <span class="hljs-keyword">new</span> Dis[<span class="hljs-keyword">this</span>-&gt;vexnum];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;vexnum; i++) &#123;<br>        arc[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-keyword">this</span>-&gt;vexnum];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-keyword">this</span>-&gt;vexnum; k++) &#123;<br>            <span class="hljs-comment">//邻接矩阵初始化为无穷大</span><br>                arc[i][k] = INT_MAX;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//析构函数</span><br>Graph_DG::~<span class="hljs-built_in">Graph_DG</span>() &#123;<br>    <span class="hljs-keyword">delete</span>[] dis;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;vexnum; i++) &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;arc[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span> arc;<br>&#125;<br><br><span class="hljs-comment">// 判断我们每次输入的的边的信息是否合法</span><br><span class="hljs-comment">//顶点从1开始编号</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Graph_DG::check_edge_value</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> weight)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start&lt;<span class="hljs-number">1</span> || end&lt;<span class="hljs-number">1</span> || start&gt;vexnum || end&gt;vexnum || weight &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph_DG::createGraph</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入每条边的起点和终点（顶点编号从1开始）以及其权重&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-type">int</span> start;<br>    <span class="hljs-type">int</span> end;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (count != <span class="hljs-keyword">this</span>-&gt;edge) &#123;<br>        cin &gt;&gt; start &gt;&gt; end &gt;&gt; weight;<br>        <span class="hljs-comment">//首先判断边的信息是否合法</span><br>        <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">check_edge_value</span>(start, end, weight)) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;输入的边的信息不合法，请重新输入&quot;</span> &lt;&lt; endl;<br>            cin &gt;&gt; start &gt;&gt; end &gt;&gt; weight;<br>        &#125;<br>        <span class="hljs-comment">//对邻接矩阵对应上的点赋值</span><br>        arc[start - <span class="hljs-number">1</span>][end - <span class="hljs-number">1</span>] = weight;<br>        <span class="hljs-comment">//无向图添加上这行代码</span><br>        <span class="hljs-comment">//arc[end - 1][start - 1] = weight;</span><br>        ++count;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph_DG::print</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;图的邻接矩阵为：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-type">int</span> count_row = <span class="hljs-number">0</span>; <span class="hljs-comment">//打印行的标签</span><br>    <span class="hljs-type">int</span> count_col = <span class="hljs-number">0</span>; <span class="hljs-comment">//打印列的标签</span><br>    <span class="hljs-comment">//开始打印</span><br>    <span class="hljs-keyword">while</span> (count_row != <span class="hljs-keyword">this</span>-&gt;vexnum) &#123;<br>        count_col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (count_col != <span class="hljs-keyword">this</span>-&gt;vexnum) &#123;<br>            <span class="hljs-keyword">if</span> (arc[count_row][count_col] == INT_MAX)<br>                cout &lt;&lt; <span class="hljs-string">&quot;∞&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">else</span><br>            cout &lt;&lt; arc[count_row][count_col] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            ++count_col;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        ++count_row;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph_DG::Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> begin)</span></span>&#123;<br>    <span class="hljs-comment">//首先初始化我们的dis数组</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;vexnum; i++) &#123;<br>        <span class="hljs-comment">//设置当前的路径</span><br>        dis[i].path = <span class="hljs-string">&quot;v&quot;</span> + <span class="hljs-built_in">to_string</span>(begin) + <span class="hljs-string">&quot;--&gt;v&quot;</span> + <span class="hljs-built_in">to_string</span>(i + <span class="hljs-number">1</span>);<br>        dis[i].value = arc[begin - <span class="hljs-number">1</span>][i];<br>    &#125;<br>    <span class="hljs-comment">//设置起点的到起点的路径为0</span><br>    dis[begin - <span class="hljs-number">1</span>].value = <span class="hljs-number">0</span>;<br>    dis[begin - <span class="hljs-number">1</span>].visit = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//计算剩余的顶点的最短路径（剩余this-&gt;vexnum-1个顶点）</span><br>    <span class="hljs-keyword">while</span> (count != <span class="hljs-keyword">this</span>-&gt;vexnum) &#123;<br>        <span class="hljs-comment">//temp用于保存当前dis数组中最小的那个下标</span><br>        <span class="hljs-comment">//min记录的当前的最小值</span><br>        <span class="hljs-type">int</span> temp=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> min = INT_MAX;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;vexnum; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!dis[i].visit &amp;&amp; dis[i].value&lt;min) &#123;<br>                min = dis[i].value;<br>                temp = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//cout &lt;&lt; temp + 1 &lt;&lt; &quot;  &quot;&lt;&lt;min &lt;&lt; endl;</span><br>        <span class="hljs-comment">//把temp对应的顶点加入到已经找到的最短路径的集合中</span><br>        dis[temp].visit = <span class="hljs-literal">true</span>;<br>        ++count;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;vexnum; i++) &#123;<br>            <span class="hljs-comment">//注意这里的条件arc[temp][i]!=INT_MAX必须加，不然会出现溢出，从而造成程序异常</span><br>            <span class="hljs-keyword">if</span> (!dis[i].visit &amp;&amp; arc[temp][i]!=INT_MAX &amp;&amp; (dis[temp].value + arc[temp][i]) &lt; dis[i].value) &#123;<br>                <span class="hljs-comment">//如果新得到的边可以影响其他为访问的顶点，那就就更新它的最短路径和长度</span><br>                dis[i].value = dis[temp].value + arc[temp][i];<br>                dis[i].path = dis[temp].path + <span class="hljs-string">&quot;--&gt;v&quot;</span> + <span class="hljs-built_in">to_string</span>(i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Graph_DG::print_path</span><span class="hljs-params">(<span class="hljs-type">int</span> begin)</span> </span>&#123;<br>    string str;<br>    str = <span class="hljs-string">&quot;v&quot;</span> + <span class="hljs-built_in">to_string</span>(begin);<br>    cout &lt;&lt; <span class="hljs-string">&quot;以&quot;</span>&lt;&lt;str&lt;&lt;<span class="hljs-string">&quot;为起点的图的最短路径为：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-keyword">this</span>-&gt;vexnum; i++) &#123;<br>        <span class="hljs-keyword">if</span>(dis[i].value!=INT_MAX)<br>        cout &lt;&lt; dis[i].path &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; dis[i].value &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; dis[i].path &lt;&lt; <span class="hljs-string">&quot;是无最短路径的&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>main.cpp文件的代码</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Dijkstra.h&quot;</span></span><br><br><br><span class="hljs-comment">//检验输入边数和顶点数的值是否有效，可以自己推算为啥：</span><br><span class="hljs-comment">//顶点数和边数的关系是：((Vexnum*(Vexnum - 1)) / 2) &lt; edge</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> Vexnum, <span class="hljs-type">int</span> edge)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Vexnum &lt;= <span class="hljs-number">0</span> || edge &lt;= <span class="hljs-number">0</span> || ((Vexnum*(Vexnum - <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span>) &lt; edge)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> vexnum; <span class="hljs-type">int</span> edge;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;输入图的顶点个数和边的条数：&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; vexnum &gt;&gt; edge;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">check</span>(vexnum, edge)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;输入的数值不合法，请重新输入&quot;</span> &lt;&lt; endl;<br>        cin &gt;&gt; vexnum &gt;&gt; edge;<br>    &#125;<br>    <span class="hljs-function">Graph_DG <span class="hljs-title">graph</span><span class="hljs-params">(vexnum, edge)</span></span>;<br>    graph.<span class="hljs-built_in">createGraph</span>();<br>    graph.<span class="hljs-built_in">print</span>();<br>    graph.<span class="hljs-built_in">Dijkstra</span>(<span class="hljs-number">1</span>);<br>    graph.<span class="hljs-built_in">print_path</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">100</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">50</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">60</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图类算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P算法</title>
    <link href="/2023/08/29/P%E7%AE%97%E6%B3%95/"/>
    <url>/2023/08/29/P%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="prim-算法"><a href="#prim-算法" class="headerlink" title="prim 算法"></a>prim 算法</h1><p>prim 算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;graph.hpp&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;crtdbg.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmpEdge</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Edge *e1, <span class="hljs-type">const</span> Edge *e2)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> e1-&gt;weight &gt; e2-&gt;weight;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Minimum Spanning Tree</span><br><span class="hljs-function">unordered_set&lt;Edge *&gt; <span class="hljs-title">primMST</span><span class="hljs-params">(Graph *graph)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 解锁的边进入小根堆</span><br>    priority_queue&lt;Edge *, vector&lt;Edge *&gt;, cmpEdge&gt; pq;<br>    unordered_set&lt;Node *&gt; myset;<br>    unordered_set&lt;Edge *&gt; result;<br><br>    <span class="hljs-comment">// 随便选择一个 Node 作为起点去解锁边</span><br>    <span class="hljs-comment">// 这里本来随便选一个 node 去处理即可，这里加上for循环遍历所有 node 仅仅是为了</span><br>    <span class="hljs-comment">// 处理森林的问题，因为可能会存在一个图有多个连通区域的情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : graph-&gt;nodes)<br>    &#123;<br>        <span class="hljs-comment">// 当前点不在 myset 点集合</span><br>        <span class="hljs-keyword">if</span> (myset.<span class="hljs-built_in">find</span>(it.second.<span class="hljs-built_in">get</span>()) == myset.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            myset.<span class="hljs-built_in">insert</span>(it.second.<span class="hljs-built_in">get</span>());<br>            <span class="hljs-comment">// 解锁跟这条边相连的所有边</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;edge : it.second.<span class="hljs-built_in">get</span>()-&gt;edges)<br>            &#123;<br>                <span class="hljs-comment">// 小根堆加入重复值会怎样</span><br>                pq.<span class="hljs-built_in">push</span>(edge);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-comment">// 弹出解锁的边中权值最小的边</span><br>                Edge *edge = pq.<span class="hljs-built_in">top</span>();<br>                pq.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 判断这个边的 toNode 是否在大集合里</span><br>                Node *toNode = edge-&gt;to;<br>                <span class="hljs-comment">// 不含有当前点则说明是新的点</span><br>                <span class="hljs-keyword">if</span> (myset.<span class="hljs-built_in">find</span>(toNode) == myset.<span class="hljs-built_in">end</span>())<br>                &#123;<br>                    result.<span class="hljs-built_in">insert</span>(edge);<br>                    <span class="hljs-comment">// 边会重复进入这个队列，即便重复的边被压入队列，但是由于toNode在大集合里面</span><br>                    <span class="hljs-comment">// 所有会直接跳过</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;nextEdge : toNode-&gt;edges)<br>                    &#123;<br>                        pq.<span class="hljs-built_in">push</span>(nextEdge);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br>        pq.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test1</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图类算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K算法</title>
    <link href="/2023/08/29/K%E7%AE%97%E6%B3%95/"/>
    <url>/2023/08/29/K%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h1><p>Kruskal 算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;graph.hpp&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;crtdbg.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">K 算法实现</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 简单的并查集的实现</span><br><span class="hljs-comment">// 并查集的功能：1、查询(O(1)时间复杂度)；2、合并(O(1)时间复杂度)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mySets</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// value 必须申请在堆上，list 类型指针也必须有唯一性，否则后面查讯集合是否为同一个集合复杂度会比较高</span><br>    <span class="hljs-comment">// 对于一般的算法机考题：Node*可以用int代替，对于list&lt;Node*&gt;*可以定义一个list&lt;Node*&gt;* arr[nodeSize]的数组</span><br>    <span class="hljs-comment">// 然后value部分也用int表示</span><br>    unordered_map&lt;Node *, list&lt;Node *&gt; *&gt; setMap;<br>    <span class="hljs-comment">// just for delete</span><br>    vector&lt;list&lt;Node *&gt; *&gt; newArr;<br><br>    <span class="hljs-built_in">mySets</span>(list&lt;Node *&gt; nodes)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;cur : nodes)<br>        &#123;<br>            list&lt;Node *&gt; *set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">list</span>&lt;Node *&gt;();<br>            newArr.<span class="hljs-built_in">push_back</span>(set);<br>            set-&gt;<span class="hljs-built_in">emplace_back</span>(cur);<br>            setMap.<span class="hljs-built_in">emplace</span>(cur, set);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 查询是否为同一个集合</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameSet</span><span class="hljs-params">(Node *from, Node *to)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (setMap.<span class="hljs-built_in">find</span>(from) == setMap.<span class="hljs-built_in">end</span>() || setMap.<span class="hljs-built_in">find</span>(to) == setMap.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        list&lt;Node *&gt; *fromSet = setMap[from];<br>        list&lt;Node *&gt; *toSet = setMap[to];<br>        <span class="hljs-keyword">return</span> fromSet == toSet;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并集合，这里时间复杂度是O(N)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionSet</span><span class="hljs-params">(Node *from, Node *to)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (setMap.<span class="hljs-built_in">find</span>(from) == setMap.<span class="hljs-built_in">end</span>() || setMap.<span class="hljs-built_in">find</span>(to) == setMap.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        list&lt;Node *&gt; *fromSet = setMap[from];<br>        list&lt;Node *&gt; *toSet = setMap[to];<br>        <span class="hljs-comment">// 将 toSet 集合中所有的节点全部由fromSet负责</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;toNode : *toSet)<br>        &#123;<br>            fromSet-&gt;<span class="hljs-built_in">emplace_back</span>(toNode);<br>            setMap[toNode] = fromSet;<br>        &#125;<br><br>        <span class="hljs-comment">// 在这里 delete toSet 或者再创建一个用于delete回收的数组</span><br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数释放申请的 list 类型指针</span><br>    ~<span class="hljs-built_in">mySets</span>()<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : newArr)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> it;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cmpEdge</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Edge *e1, <span class="hljs-type">const</span> Edge *e2)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> e1-&gt;weight &gt; e2-&gt;weight;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">unordered_set&lt;Edge *&gt; <span class="hljs-title">kruskalMST</span><span class="hljs-params">(Graph *graph)</span></span><br><span class="hljs-function"></span>&#123;<br>    list&lt;Node *&gt; nodes;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : graph-&gt;nodes)<br>    &#123;<br>        nodes.<span class="hljs-built_in">emplace_back</span>(it.second.<span class="hljs-built_in">get</span>());<br>    &#125;<br>    <span class="hljs-function">mySets <span class="hljs-title">myset</span><span class="hljs-params">(nodes)</span></span>;<br>    <span class="hljs-comment">// 以 Edge 的 weight 属性来构建小根堆</span><br>    priority_queue&lt;Edge *, vector&lt;Edge *&gt;, cmpEdge&gt; pq;<br>    <span class="hljs-comment">// M 条边 O(logM)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;edge : graph-&gt;edges)<br>    &#123;<br>        pq.<span class="hljs-built_in">push</span>(edge.<span class="hljs-built_in">get</span>());<br>    &#125;<br><br>    unordered_set&lt;Edge *&gt; res;<br>    <span class="hljs-comment">// M 条边 O(logM)</span><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        Edge *edge = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// O(1)</span><br>        <span class="hljs-keyword">if</span> (!myset.<span class="hljs-built_in">isSameSet</span>(edge-&gt;from, edge-&gt;to))<br>        &#123;<br>            res.<span class="hljs-built_in">insert</span>(edge);<br>            <span class="hljs-comment">// 这里用真正的并查集可以做到 O(1)</span><br>            myset.<span class="hljs-built_in">unionSet</span>(edge-&gt;from, edge-&gt;to);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Node <span class="hljs-title">n1</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">Node <span class="hljs-title">n2</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Node <span class="hljs-title">n3</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>    list&lt;Node *&gt; nodes = &#123;&amp;n1, &amp;n2, &amp;n3&#125;;<br>    <span class="hljs-function">mySets <span class="hljs-title">set</span><span class="hljs-params">(nodes)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : *(set.setMap[&amp;n2]))<br>    &#123;<br>        cout &lt;&lt; it-&gt;value &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// _CrtDumpMemoryLeaks();//检测内存泄露</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; matrix = &#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">100000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;&#125;;<br>    shared_ptr&lt;Graph&gt; graph = <span class="hljs-built_in">creatGraph</span>(matrix);<br>    unordered_set&lt;Edge *&gt; res = <span class="hljs-built_in">kruskalMST</span>(graph.<span class="hljs-built_in">get</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; it : res)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;weight: &quot;</span> &lt;&lt; it-&gt;weight &lt;&lt; <span class="hljs-string">&quot;; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;from: &quot;</span> &lt;&lt; it-&gt;from-&gt;value &lt;&lt; <span class="hljs-string">&quot;; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;to: &quot;</span> &lt;&lt; it-&gt;to-&gt;value &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test2</span>();<br><br>    _CrtDumpMemoryLeaks(); <span class="hljs-comment">// 检测内存泄露</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图类算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度优先搜索</title>
    <link href="/2023/08/29/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2023/08/29/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>深度优先搜索</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;graph.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node *node)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    stack&lt;Node *&gt; sta;<br>    unordered_set&lt;Node *&gt; hashset;<br>    sta.<span class="hljs-built_in">push</span>(node);<br>    hashset.<span class="hljs-built_in">insert</span>(node);<br>    <span class="hljs-comment">// todo</span><br>    cout &lt;&lt; node-&gt;value &lt;&lt; endl;<br>    <span class="hljs-keyword">while</span> (!sta.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        Node *cur = sta.<span class="hljs-built_in">top</span>();<br>        sta.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;next : cur-&gt;nexts)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (hashset.<span class="hljs-built_in">find</span>(next) == hashset.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                sta.<span class="hljs-built_in">push</span>(cur);<br>                sta.<span class="hljs-built_in">push</span>(next);<br>                hashset.<span class="hljs-built_in">insert</span>(next);<br>                <span class="hljs-comment">// todo</span><br>                cout &lt;&lt; next-&gt;value &lt;&lt; endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图类算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广度优先搜索</title>
    <link href="/2023/08/29/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2023/08/29/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>广度优先搜索</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;graph.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(Node *node)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// queue&lt;Node*, list&lt;Node*&gt;&gt; que;</span><br>    queue&lt;Node *&gt; que;<br>    unordered_set&lt;Node *&gt; hashset;<br>    que.<span class="hljs-built_in">push</span>(node);<br>    hashset.<span class="hljs-built_in">insert</span>(node);<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        Node *cur = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// todo</span><br>        cout &lt;&lt; cur-&gt;value &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;next : cur-&gt;nexts)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (hashset.<span class="hljs-built_in">find</span>(next) == hashset.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                hashset.<span class="hljs-built_in">insert</span>(next);<br>                que.<span class="hljs-built_in">push</span>(next);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;graph.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;crtdbg.h&gt;</span></span><br><br>vector&lt;vector&lt;Node *&gt;&gt; <span class="hljs-built_in">sortedTopology</span>(Graph *graph)<br>&#123;<br>    <span class="hljs-comment">// key: 某一个node， value: 剩余的入度</span><br>    unordered_map&lt;Node *, <span class="hljs-type">int</span>&gt; inMap;<br>    <span class="hljs-comment">// 入度为 0 的 node 才能进这个队列</span><br>    queue&lt;Node *&gt; zeroInQue;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;node : graph-&gt;nodes)<br>    &#123;<br>        inMap[node.second.<span class="hljs-built_in">get</span>()] = node.second.<span class="hljs-built_in">get</span>()-&gt;in;<br>        <span class="hljs-keyword">if</span> (node.second.<span class="hljs-built_in">get</span>()-&gt;in == <span class="hljs-number">0</span>)<br>        &#123;<br>            zeroInQue.<span class="hljs-built_in">push</span>(node.second.<span class="hljs-built_in">get</span>());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// count1 表示批量编译了几次；count2 表示总共有多少文件被成功编译了</span><br>    <span class="hljs-comment">// 如果 count2 != graph-&gt;nodes.size() 则说明图中存在环（ps：隔离开的两个图也是能编译的）</span><br>    <span class="hljs-type">int</span> count1 = <span class="hljs-number">0</span>, count2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 拓扑排序的结果放入result</span><br>    vector&lt;vector&lt;Node *&gt;&gt; result;<br>    <span class="hljs-keyword">while</span> (!zeroInQue.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> size = zeroInQue.<span class="hljs-built_in">size</span>();<br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;Node*&gt;());<br>        <span class="hljs-keyword">while</span> (size--)<br>        &#123;<br>            Node *cur = zeroInQue.<span class="hljs-built_in">front</span>();<br>            zeroInQue.<span class="hljs-built_in">pop</span>();<br>            result[count1].<span class="hljs-built_in">push_back</span>(cur);<br>            count2++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; next : cur-&gt;nexts)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(--inMap[next] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    zeroInQue.<span class="hljs-built_in">push</span>(next);<br>                &#125;<br>            &#125;<br>        &#125;<br>        count1++;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (count2 != graph-&gt;nodes.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;There is a cyclic dependency&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt; matrix = &#123;&#123;1, 1, 2&#125;, &#123;1, 2, 3&#125;, &#123;1, 3, 4&#125;, &#123;1, 1, 5&#125;, &#123;1, 1, 3&#125;, &#123;1, 2, 4&#125;&#125;;</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; matrix = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;&#125;;<br><br>    shared_ptr&lt;Graph&gt; graph = <span class="hljs-built_in">creatGraph</span>(matrix);<br>    vector&lt;vector&lt;Node *&gt;&gt; res = <span class="hljs-built_in">sortedTopology</span>(graph.<span class="hljs-built_in">get</span>());<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test1</span>();<br>    _CrtDumpMemoryLeaks();<span class="hljs-comment">//检测内存泄露</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图类算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的构建</title>
    <link href="/2023/08/29/%E5%9B%BE%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
    <url>/2023/08/29/%E5%9B%BE%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="图的构建"><a href="#图的构建" class="headerlink" title="图的构建"></a>图的构建</h1><p>图的构建</p><p><code>graph.hpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-comment">// in表示一个点的入度，表示有多少个有向边的箭头指向它</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> in;<br>    <span class="hljs-comment">// out表示一个点的出度，表示有多少个边是从这个点指向外面的</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> out;<br>    vector&lt;Node*&gt; nexts;<br>    vector&lt;Edge*&gt; edges;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> val)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;value = val;<br>        in = <span class="hljs-number">0</span>;<br>        out = <span class="hljs-number">0</span>;<br>        nexts = <span class="hljs-built_in">vector</span>&lt;Node*&gt;();<br>        edges = <span class="hljs-built_in">vector</span>&lt;Edge*&gt;();<br>    &#125;<br>    ~<span class="hljs-built_in">Node</span>()<br>    &#123;<br>        nexts.<span class="hljs-built_in">clear</span>();<br>        edges.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> weight;<br>    Node* from;<br>    Node* to;<br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> wei, Node* f, Node* t)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;weight = wei;<br>        <span class="hljs-keyword">this</span>-&gt;from = f;<br>        <span class="hljs-keyword">this</span>-&gt;to = t;<br>    &#125;<br>    <span class="hljs-built_in">Edge</span>(Node* f, Node* t)<br>    &#123;<br>        <span class="hljs-keyword">this</span>-&gt;from = f;<br>        <span class="hljs-keyword">this</span>-&gt;to = t;<br>    &#125;<br>    ~<span class="hljs-built_in">Edge</span>()<br>    &#123;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 把所有的点集和边集合都委托给Graph结构来管理</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, shared_ptr&lt;Node&gt;&gt; nodes;<br>    unordered_set&lt;shared_ptr&lt;Edge&gt;&gt; edges;<br>    <span class="hljs-built_in">Graph</span>()<br>    &#123;<br>        nodes = unordered_map&lt;<span class="hljs-type">int</span>, shared_ptr&lt;Node&gt;&gt;();<br>        edges = unordered_set&lt;shared_ptr&lt;Edge&gt;&gt;();<br>    &#125;<br>    ~<span class="hljs-built_in">Graph</span>()<br>    &#123;<br>        nodes.<span class="hljs-built_in">clear</span>();<br>        edges.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// matrix 每一行表示图中的边</span><br><span class="hljs-comment">// 必须为N*3的矩阵</span><br><span class="hljs-comment">// [weight, fromNode, toNode]</span><br><span class="hljs-function">std::shared_ptr&lt;Graph&gt; <span class="hljs-title">creatGraph</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// shared_ptr&lt;Graph&gt; graph = make_shared&lt;Graph&gt;(Graph());</span><br>    shared_ptr&lt;Graph&gt; graph = <span class="hljs-built_in">shared_ptr</span>&lt;Graph&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Graph</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-type">int</span> weight = matrix[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> from = matrix[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> to = matrix[i][<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span> (graph.<span class="hljs-built_in">get</span>()-&gt;nodes.<span class="hljs-built_in">find</span>(from) == graph.<span class="hljs-built_in">get</span>()-&gt;nodes.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            graph.<span class="hljs-built_in">get</span>()-&gt;nodes[from] = <span class="hljs-built_in">shared_ptr</span>&lt;Node&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(from));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (graph.<span class="hljs-built_in">get</span>()-&gt;nodes.<span class="hljs-built_in">find</span>(to) == graph.<span class="hljs-built_in">get</span>()-&gt;nodes.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            graph.<span class="hljs-built_in">get</span>()-&gt;nodes[to] = <span class="hljs-built_in">shared_ptr</span>&lt;Node&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(to));<br>        &#125;<br>        Node* fromNode = graph.<span class="hljs-built_in">get</span>()-&gt;nodes[from].<span class="hljs-built_in">get</span>();<br>        Node* toNode = graph.<span class="hljs-built_in">get</span>()-&gt;nodes[to].<span class="hljs-built_in">get</span>();<br>        shared_ptr&lt;Edge&gt; newEdge = <span class="hljs-built_in">shared_ptr</span>&lt;Edge&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Edge</span>(weight, fromNode, toNode));<br>        fromNode-&gt;nexts.<span class="hljs-built_in">emplace_back</span>(toNode);<br>        fromNode-&gt;out++;<br>        toNode-&gt;in++;<br>        fromNode-&gt;edges.<span class="hljs-built_in">emplace_back</span>(newEdge.<span class="hljs-built_in">get</span>());<br>        graph.<span class="hljs-built_in">get</span>()-&gt;edges.<span class="hljs-built_in">insert</span>(newEdge);<br>    &#125;<br>    <span class="hljs-comment">// new int(1);</span><br>    <span class="hljs-comment">// 0 内存泄漏！！！</span><br>    <span class="hljs-keyword">return</span> graph;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>testGraph.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;graph.hpp&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;crtdbg.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; matrix = &#123; &#123;<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125; &#125;;<br>    shared_ptr&lt;Graph&gt; graph = <span class="hljs-built_in">creatGraph</span>(matrix);<br>    cout &lt;&lt; graph.<span class="hljs-built_in">get</span>()-&gt;nodes[<span class="hljs-number">1</span>].<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br>    graph.<span class="hljs-built_in">reset</span>();<br><br>    cout &lt;&lt; graph.<span class="hljs-built_in">get</span>()-&gt;nodes[<span class="hljs-number">1</span>].<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br><br>    _CrtDumpMemoryLeaks();<span class="hljs-comment">//检测内存泄露</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="graph"><a href="#graph" class="headerlink" title="graph"></a>graph</h1><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>使用 shared_ptr 可以避免许多内存泄漏的情况，但不是所有情况都能解决。shared_ptr 依赖于引用计数技术，它会记录指向对象的指针数量，当数量为 0 时自动删除对象。但是，在某些情况下仍然可能发生内存泄漏。以下是可能会导致内存泄漏的情况：</p><p>循环引用。如果你的对象存在循环引用，即使你使用 shared_ptr，也可能会发生内存泄漏。例如，如果对象A中包含一个 std::shared_ptr&lt;B&gt;，而对象B中包含一个 std::shared_ptr&lt;A&gt;，那么当你删除对象A和B时，它们之间互相持有的指针数量永远不会变成 0，从而导致内存泄漏。</p><p>基类和派生类之间的显式指针。如果你使用了基类和派生类之间的显式指针，可能会导致内存泄漏，因为引用计数技术无法追踪这些指针。例如，如果你使用了一个 std::shared_ptr&lt;A&gt;，并将其指向了派生类B的实例，那么当你删除该 shared_ptr 时，B 对象中的成员变量仍然可能包含指向 A 对象的指针，从而导致内存泄漏。</p><p>自定义删除器。 如果你使用 shared_ptr 自定义了删除器，那么你需要确保你的删除器适当地清理了指针持有的资源。否则，你可能会在删除对象时发生内存泄漏。</p><p>shared_ptr 和 new[] 的组合。 如果你使用了 std::shared_ptr 来管理一个使用 new[] 分配的数组，你需要使用 std::shared_ptr 提供的定制删除器，以避免内存泄漏。原因是 std::shared_ptr 并不知道它指向的是一个数组，而 delete 只能删除由 new 分配的单个对象。</p><p>总之，虽然 std::shared_ptr 可以减少内存泄漏的情况，但并不能完全避免。你需要注意以避免上述情况，从而减少内存泄漏的发生。如果你使用 _CrtDumpMemoryLeaks 或其他工具来检测内存泄漏，你应该注意该工具是否对 std::shared_ptr 的使用进行了正确的跟踪。</p><h2 id="CrtDumpMemoryLeaks"><a href="#CrtDumpMemoryLeaks" class="headerlink" title="_CrtDumpMemoryLeaks"></a>_CrtDumpMemoryLeaks</h2><p>_CrtDumpMemoryLeaks 是 VC++ 提供用于检测内存泄漏的函数，它是定义在 crtdbg.h 头文件中的。</p><p>在 C&#x2F;C++ 语言开发中，内存泄漏是一种很严重的问题。某些情况下，程序员开发的代码中申请了内存空间但没有释放，导致内存泄漏的情况出现。内存泄漏会导致程序运行变慢，有时还会引发崩溃、卡死等问题。</p><p>为了及时发现和解决内存泄漏问题，可以使用 _CrtDumpMemoryLeaks 函数来检测有没有内存泄漏。使用该函数时，需要包含 crtdbg.h 头文件，并将_CRTDBG_LEAK_CHECK_DF 宏设置为 _CrtSetDbgFlag 函数的参数，然后程序运行结束后就会在调试输出中显示内存泄漏的信息。如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRTDBG_MAP_ALLOC</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;crtdbg.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);<br>    <span class="hljs-comment">// do something</span><br>    _CrtDumpMemoryLeaks();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>k算法和p算法都是仅仅针对无向图的算法</p><h3 id="kruskal-算法"><a href="#kruskal-算法" class="headerlink" title="kruskal 算法"></a>kruskal 算法</h3><p>算法思想和证明方式</p><p>k算法：每次选择权值最小的边，如果不存在环，则收集。否者进入下一次循环选择权值最小的边。直到所有的边都遍历过一遍。 那么如果判断是否存在环，用并集技巧。</p><h3 id="prim-算法"><a href="#prim-算法" class="headerlink" title="prim 算法"></a>prim 算法</h3><p>K算法可能有一个集合被吞入另一个集合的情况，谁被吞不确定，但P算法只有一个大集合</p><p>就是k算法可能有一个一个点往集合里加的情况，也可能有一片一片的加的情况</p><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>从规定的出发节点到所有节点的最短路径</p><p>适用范围：不能有累加和为负数的环</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图的构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人项目</title>
    <link href="/2023/08/29/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/08/29/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="流媒体项目"><a href="#流媒体项目" class="headerlink" title="流媒体项目"></a>流媒体项目</h1><p><img src="%E6%B5%81%E5%AA%92%E4%BD%93%E9%A1%B9%E7%9B%AE1.png" alt="流媒体项目"></p><p><img src="%E6%B5%81%E5%AA%92%E4%BD%93%E9%A1%B9%E7%9B%AE2.png" alt="流媒体项目"></p><p><img src="%E6%B5%81%E5%AA%92%E4%BD%93%E9%A1%B9%E7%9B%AE3.png" alt="流媒体项目"></p>]]></content>
    
    
    <categories>
      
      <category>个人项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>whc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2023/08/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/08/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划的四种模型"><a href="#动态规划的四种模型" class="headerlink" title="动态规划的四种模型"></a>动态规划的四种模型</h1><p>解决动态规划问题的一般思路：先写出暴力“尝试”的方法（递归、人的自然智慧），然后基于暴力递归看是否右重复求解的情况来写出“傻缓存”的方法，最后尝试基于暴力递归写出动态优化的版本</p><h2 id="从左向右的尝试模型"><a href="#从左向右的尝试模型" class="headerlink" title="从左向右的尝试模型"></a>从左向右的尝试模型</h2><p><code>经典题型</code>：斐波那契数列、走楼梯</p><h2 id="范围尝试模型"><a href="#范围尝试模型" class="headerlink" title="范围尝试模型"></a>范围尝试模型</h2><p><code>经典题型</code>：机器人走路（1~N的位置上）、马在棋盘上跳（棋盘大小为10*9）、01背包问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 假设有排成一行的N个位置，记为1~N,N一定大于或等于2开始时机器人在其中的M位置上(M一定是1~N中的一个)</span><br><span class="hljs-comment">// 如果机器人来到1位置，那么下一步只能往右来到2位置﹔如果机器人来到N位置，那么下一步只能往左来到N-1位置;</span><br><span class="hljs-comment">// 如果机器人来到中间位置，那么下一步可以往左走或者往右走;</span><br><span class="hljs-comment">// 规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个)的方法有多少种给定四个参数N、M、K、P，返回方法数。</span><br><br><br><span class="hljs-comment">// 机器人当前来到的位置是cur,</span><br><span class="hljs-comment">// 机器人还有rest步需要去走,</span><br><span class="hljs-comment">// 最终的目标是aim,</span><br><span class="hljs-comment">// 有哪些位置?1~N</span><br><span class="hljs-comment">// 返回:机器人从cur出发,走过rest步之后,最终停在aim的方法数,是多少?</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> rest, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 经过 rest 步之后最终到达 aim，则说明这是一次成功的暴力递归搜索到的方法</span><br>        <span class="hljs-keyword">return</span> cur == aim ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// rest &gt; 0 还剩有步数</span><br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 1 -&gt; 2</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">process1</span>(<span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cur == N)<br>    &#123;<br>        <span class="hljs-comment">// N-1 &lt;- N</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">process1</span>(N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>    &#125;<br>    <span class="hljs-comment">// 中间位置上</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">process1</span>(cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N) + <span class="hljs-built_in">process1</span>(cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ways1</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> K)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span> || start &lt; <span class="hljs-number">1</span> || start &gt; N || aim &lt; <span class="hljs-number">1</span> || aim &gt; N || K &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">process1</span>(start, K, aim, N);<br>&#125;<br><br><span class="hljs-comment">// cur的范围：1~N</span><br><span class="hljs-comment">// rest的范围：0~K</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> rest, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> N, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;dp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (dp[cur][rest] != <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> dp[cur][rest];<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>)<br>    &#123;<br>        ans = cur == aim ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>)<br>    &#123;<br>        ans = <span class="hljs-built_in">process2</span>(<span class="hljs-number">2</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == N)<br>    &#123;<br>        ans = <span class="hljs-built_in">process2</span>(N - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ans = <span class="hljs-built_in">process2</span>(cur - <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp) + <span class="hljs-built_in">process2</span>(cur + <span class="hljs-number">1</span>, rest - <span class="hljs-number">1</span>, aim, N, dp);<br>    &#125;<br>    dp[cur][rest] = ans;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">// 缓存的方法: 确保了重复的过程只会进入一遍</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ways2</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> K)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(K + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">process2</span>(start, K, aim, N, dp);<br>&#125;<br><br><span class="hljs-comment">// 动态规划 状态转移矩阵</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ways3</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> aim, <span class="hljs-type">int</span> K)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(K + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    dp[aim][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> rest = <span class="hljs-number">1</span>; rest &lt;= K; rest++)<br>    &#123;<br>        <span class="hljs-comment">// 当机器人来到边界位置的时候只依赖一个位置</span><br>        dp[<span class="hljs-number">1</span>][rest] = dp[<span class="hljs-number">2</span>][rest - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur = <span class="hljs-number">2</span>; cur &lt; N; cur++)<br>        &#123;<br>            <span class="hljs-comment">// 当机器人来到中间的位置的时候依赖的是左右两个位置</span><br>            dp[cur][rest] = dp[cur - <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>] + dp[cur + <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>];<br>        &#125;<br>        dp[N][rest] = dp[N - <span class="hljs-number">1</span>][rest - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// 最终要返回 start 位置开始走 K 步到 aim 的方法数</span><br>    <span class="hljs-keyword">return</span> dp[start][K];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 从 start 位置开始</span><br>    <span class="hljs-type">int</span> start = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 走 K 步</span><br>    <span class="hljs-type">int</span> K = <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">// 目标位置是 aim</span><br>    <span class="hljs-type">int</span> aim = <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 总共有 1~N 个位置</span><br>    <span class="hljs-type">int</span> N = <span class="hljs-number">5</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">ways1</span>(N, start, aim, K) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">ways2</span>(N, start, aim, K) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">ways3</span>(N, start, aim, K) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test1</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 给定长度都为N的数组weights和values，weights[i]values[i]分别代表</span><br><span class="hljs-comment">// i号物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子</span><br><span class="hljs-comment">// 你装的物品不能超过这个重量。返回你能装的最大价值是多少？</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-comment">// i... 的货物自由选择，形成的最大价值返回</span><br><span class="hljs-comment">// 重量永远不要超过bag</span><br><span class="hljs-comment">// 之前做的决定，所达到的重量，alreadyweight</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;weights, vector&lt;<span class="hljs-type">int</span>&gt; &amp;values, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> alreadyweight, <span class="hljs-type">int</span> bag)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (alreadyweight &gt; bag)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 没有货物的最大价值当然为0</span><br>    <span class="hljs-keyword">if</span> (i == weights.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">process1</span>(weights, values, i + <span class="hljs-number">1</span>, alreadyweight, bag),<br>               values[i] + <span class="hljs-built_in">process1</span>(weights, values, i + <span class="hljs-number">1</span>, alreadyweight + weights[i], bag));<br>&#125;<br><span class="hljs-comment">// 另外一种暴力递归的写法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">process2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;weights, vector&lt;<span class="hljs-type">int</span>&gt; &amp;values, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> alreadyWeight, <span class="hljs-type">int</span> alreadyValue, <span class="hljs-type">int</span> bag)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (alreadyWeight &gt; bag)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (i == values.<span class="hljs-built_in">size</span>())<br>        <span class="hljs-keyword">return</span> alreadyValue;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">process2</span>(weights, values, i + <span class="hljs-number">1</span>, alreadyWeight, alreadyValue, bag),<br>               <span class="hljs-built_in">process2</span>(weights, values, i + <span class="hljs-number">1</span>, alreadyWeight + weights[i], alreadyValue + values[i], bag));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;weights, vector&lt;<span class="hljs-type">int</span>&gt; &amp;values, <span class="hljs-type">int</span> bag)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">process1</span>(weights, values, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bag);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="样本对应模型"><a href="#样本对应模型" class="headerlink" title="样本对应模型"></a>样本对应模型</h2><p><code>经典题型</code>：最长公共子序列、最长回文子序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 最长公共子序列</span><br><br><span class="hljs-comment">// str1[0...j] str2[0...j]最长公共子序列多长</span><br><span class="hljs-comment">// 返回</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">process1</span><span class="hljs-params">(string &amp;str1, string &amp;str2, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> str1[i] == str2[j] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (str1[i] == str2[j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">process1</span>(str1, str2, i, j - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (str1[i] == str2[j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">process1</span>(str1, str2, i - <span class="hljs-number">1</span>, j);<br>    &#125;<br>    <span class="hljs-comment">// i != 0 &amp;&amp; j != 0</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 考虑最长公共子序列以 str1[i] 结尾的情况</span><br>        <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">process1</span>(str1, str2, i, j - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 考虑最长公共子序列以 str2[j] 结尾的情况</span><br>        <span class="hljs-type">int</span> p2 = <span class="hljs-built_in">process1</span>(str1, str2, i - <span class="hljs-number">1</span>, j);<br>        <span class="hljs-comment">// 最长公共子序列必须以 str1[i] 和 str2[j] 结尾，但是有这两个字符相等的前提</span><br>        <span class="hljs-type">int</span> p3 = str1[i] == str2[j] ? (<span class="hljs-number">1</span> + <span class="hljs-built_in">process1</span>(str1, str2, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>)) : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(p1, <span class="hljs-built_in">max</span>(p2, p3));<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence1</span><span class="hljs-params">(string &amp;text1, string &amp;text2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (text1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || text2.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">process1</span>(text1, text2, text1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, text2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence2</span><span class="hljs-params">(string &amp;text1, string &amp;text2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (text1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || text2.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> N = text1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> M = text2.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = text1[<span class="hljs-number">0</span>] == text2[<span class="hljs-number">0</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; M; j++)<br>    &#123;<br>        dp[<span class="hljs-number">0</span>][j] = text1[<span class="hljs-number">0</span>] == text2[j] ? <span class="hljs-number">1</span> : dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)<br>    &#123;<br>        dp[i][<span class="hljs-number">0</span>] = text1[i] == text2[<span class="hljs-number">0</span>] ? <span class="hljs-number">1</span> : dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; M; j++)<br>        &#123;<br>            <span class="hljs-type">int</span> p1 = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-type">int</span> p2 = dp[i][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> p3 = text1[i] == text2[j] ? (<span class="hljs-number">1</span> + dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) : <span class="hljs-number">0</span>;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(p1, <span class="hljs-built_in">max</span>(p2, p3));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[N - <span class="hljs-number">1</span>][M - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string text1 = <span class="hljs-string">&quot;1a2a34a56&quot;</span>;<br>    string text2 = <span class="hljs-string">&quot;afdgafgfd123456dhasgfagfarug&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">longestCommonSubsequence1</span>(text1, text2) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">longestCommonSubsequence2</span>(text1, text2) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test1</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="业务限制模型"><a href="#业务限制模型" class="headerlink" title="业务限制模型"></a>业务限制模型</h2><p><code>经典题型</code>：咖啡杯问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 给定一个数组arr,arr[i]代表第i号咖啡机泡一杯咖啡的时间</span><br><span class="hljs-comment">// 给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡</span><br><span class="hljs-comment">// 只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯</span><br><span class="hljs-comment">// 每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发</span><br><span class="hljs-comment">// 假设所有人拿到咖啡之后立刻喝干净，</span><br><span class="hljs-comment">// 返回从开始等到所有咖啡机变干净的最短时间</span><br><span class="hljs-comment">// 三个参数:int[]arr、int N, int a、int b</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Machine</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> timePoint;<br>    <span class="hljs-type">int</span> workTime;<br>    <span class="hljs-built_in">Machine</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w) : <span class="hljs-built_in">timePoint</span>(t), <span class="hljs-built_in">workTime</span>(w) &#123;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Machine &amp;m1) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> timePoint + workTime &gt; m1.timePoint + m1.workTime;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// drinks 所有杯子开始洗的时间；升序</span><br><span class="hljs-comment">// wash 单杯洗干净的时间（串行）</span><br><span class="hljs-comment">// air 挥发干净的时间（并行）</span><br><span class="hljs-comment">// free 洗咖啡杯的机器什么时候可用</span><br><span class="hljs-comment">// drinks[index ... ] 都变干净，最早的时间返回</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">bestTime</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;drinks, <span class="hljs-type">int</span> wash, <span class="hljs-type">int</span> air, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> free)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (index == drinks.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// index 号杯子决定洗</span><br>    <span class="hljs-type">int</span> selfClean1 = <span class="hljs-built_in">max</span>(drinks[index], free) + wash;<br>    <span class="hljs-type">int</span> restClean1 = <span class="hljs-built_in">bestTime</span>(drinks, wash, air, index + <span class="hljs-number">1</span>, selfClean1);<br>    <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">max</span>(selfClean1, restClean1);<br>    <span class="hljs-comment">// index 号杯子决定挥发</span><br>    <span class="hljs-type">int</span> selfClean2 = drinks[index] + air;<br>    <span class="hljs-type">int</span> restClean2 = <span class="hljs-built_in">bestTime</span>(drinks, wash, air, index + <span class="hljs-number">1</span>, free);<br>    <span class="hljs-type">int</span> p2 = <span class="hljs-built_in">max</span>(selfClean2, restClean2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(p1, p2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">bestTimeDp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;drinks, <span class="hljs-type">int</span> wash, <span class="hljs-type">int</span> air)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N = drinks.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> maxFree = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        maxFree = <span class="hljs-built_in">max</span>(maxFree, drinks[i]) + wash;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(N + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(maxFree + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// dp[N][...] = 0;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = N - <span class="hljs-number">1</span>; index &gt;= <span class="hljs-number">0</span>; index--)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> free = <span class="hljs-number">0</span>; free &lt;= maxFree; free++)<br>        &#123;<br>            <span class="hljs-type">int</span> selfClean1 = <span class="hljs-built_in">max</span>(drinks[index], free) + wash;<br>            <span class="hljs-keyword">if</span> (selfClean1 &gt; maxFree)<br>            &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> restClean1 = dp[index + <span class="hljs-number">1</span>][selfClean1];<br>            <span class="hljs-type">int</span> p1 = <span class="hljs-built_in">max</span>(selfClean1, restClean1);<br><br>            <span class="hljs-type">int</span> selfClean2 = drinks[index] + air;<br>            <span class="hljs-type">int</span> restClean2 = dp[index + <span class="hljs-number">1</span>][free];<br>            <span class="hljs-type">int</span> p2 = <span class="hljs-built_in">max</span>(selfClean2, restClean2);<br>            dp[index][free] = <span class="hljs-built_in">min</span>(p1, p2);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minTime1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    priority_queue&lt;Machine&gt; heap;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Machine</span>(<span class="hljs-number">0</span>, arr[i]));<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">drinks</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        Machine cur = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>        cur.timePoint += cur.workTime;<br>        drinks[i] = cur.timePoint;<br>        heap.<span class="hljs-built_in">push</span>(cur);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bestTime</span>(drinks, a, b, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// return bestTimeDp(drinks, a, b);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    priority_queue&lt;Machine&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Machine</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<br>    heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Machine</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>));<br>    heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Machine</span>(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>));<br>    <span class="hljs-keyword">while</span> (!heap.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        cout &lt;&lt; heap.<span class="hljs-built_in">top</span>().timePoint &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; heap.<span class="hljs-built_in">top</span>().workTime &lt;&lt; endl;<br>        heap.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">minTime1</span>(arr, n, a, b) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// test1();</span><br>    <span class="hljs-built_in">test2</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划的四种模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cppNotes</title>
    <link href="/2023/08/13/cppNotes/"/>
    <url>/2023/08/13/cppNotes/</url>
    
    <content type="html"><![CDATA[<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>在C++中，初始化列表（initializer list）是用于初始化类成员变量的一种方式。以下是必须在初始化列表中初始化的情况：</p><ul><li><p>常量成员变量（const）：由于常量成员变量在创建对象时必须进行初始化，因此它们必须在初始化列表中初始化。</p></li><li><p>引用成员变量（reference）：引用必须在创建对象时初始化，并且一旦初始化后，就不能再引用其他对象。因此，引用成员变量必须在初始化列表中初始化。</p></li><li><p>成员变量对象（member object）：如果类包含其他类的对象作为成员变量，而这些成员对象没有默认构造函数或者需要传递参数进行初始化，那么它们必须在初始化列表中初始化。</p></li></ul><p>以下是不能在初始化列表中初始化的情况：</p><ul><li><p>静态成员变量（static）：静态成员变量在类定义外进行初始化，而不是在构造函数或初始化列表中。</p></li><li><p>父类的成员变量不能在子类的初始化列表中直接进行初始化，可以在父类的初始化列表中初始化</p></li></ul><h2 id="GCC编译器的结构体对齐指令"><a href="#GCC编译器的结构体对齐指令" class="headerlink" title="GCC编译器的结构体对齐指令"></a>GCC编译器的结构体对齐指令</h2><p>gcc推荐的结构体对齐指令</p><pre><code class="hljs">   __attribute__((packed))   __attribute__((aligned(n)))</code></pre><p>(1) <code>__attribute__((packed))</code>使用时直接放在要进行内存对齐的类型定义的后面，然后它起作用的范围只有加了这个东西的这一个类型。packed的作用就是取消对齐访问。</p><p>注意：定义变量时，加 <code>__attribute__((packed))</code> 是不起作用的，说明<code>__attribute__((packed))</code>只能加在结构体类型后面，只能影响这个结构体类型的整体自己。</p><p>(2) <code>__attribute__((aligned(n)))</code>使用时直接放在要进行内存对齐的类型定义的后面，然后它起作用的范围只有加了这个东西的这一个类型。它的作用是让整个结构体变量整体进行n字节对齐。</p><p>（注意<code>__attribute__((aligned(n)))</code>的作用是结构体变量整体n字节对齐，而不是结构体内各元素也要n字节对齐），这句话什么意思呢？简单理解：当32位编译器，默认对齐时4字节对齐，但是你会发现一个奇怪现象，当 <code>__attribute__((aligned(n)))</code>中的n&#x3D;1、2、4时，他的打印结果都是12（这是4字节对齐的结果：12&#x3D;4+2+2+4），因此可以看出，这里并不是要求结构体内部各元素都要按照n字节对齐，而是要求结构体整体对齐。只有当n的数值大于或等于4时（要求是2的幂次方）才会起作用。</p><h2 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h2><p>ACM 输入输出模式必学的技巧：getline 和 stringstream</p><p>getline 函数原型</p><p>template&lt; class CharT, class Traits, class Allocator &gt;<br>std::basic_istream&lt;CharT,Traits&gt;&amp; getline( std::basic_istream&lt;CharT,Traits&gt;&amp;&amp; input,<br>                                           std::basic_string&lt;CharT,Traits,Allocator&gt;&amp; str,<br>                                           CharT delim );</p><p>getline 从输入流读取字符并将它们放进 string ：</p><ol><li><p>表现为无格式输入函数 (UnformattedInputFunction) ，除了不影响 input.gcount() 。构造并检查 sentry 对象后，进行下列操作：</p><pre><code class="hljs">1. 调用 str.erase()2. 从 input 释出字符并后附它们到 str ，直至发生下列条件之一（按顺序检查）：       1. input 上的文件尾条件，该情况下， getline 设置 eofbit 。       2. 下个可用输入字符是 delim ，以 Traits::eq(c, delim) 测试，该情况下从 input 释出分隔字符，但不后附它到 str 。       3. 已经存储 str.max_size() 个字符，该情况下 getline 设置 failbit 并返回。3. 若因任何原因（不是舍弃的分隔符）没有释出字符，则 getline 设置 failbit 并返回。</code></pre></li><li><p>同 getline(input, str, input.widen(‘\n’)) ，即默认分隔符是换行符。</p></li></ol><ul><li>参数</li></ul><p><code>input</code>-获取数据来源的流<br><code>str</code>-放置数据的目标 string<br><code>delim</code>-分隔字符</p><ul><li>返回值</li></ul><p><code>input</code></p><ul><li>注解</li></ul><p>消耗空白符分隔的输入（例如 int n; std::cin &gt;&gt; n; ）时，任何后随的空白符，包括换行符都会被留在流中。然后当切换到面向行的输入时，以 getline 取得的首行只会是该空白符。多数情况下这是不想要的行为，可能的解法包括：</p><p>对 getline 的显式的额外初始调用<br>以 std::cin &gt;&gt; std::ws 移除额外的空白符<br>以 std::cin.ignore(std::numeric_limits<a href="std::streamsize">std::streamsize</a>::max(), ‘\n’); 忽略输入行上剩下的全部字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    stringstream ss;<br>    string ip = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    ss &lt;&lt; ip;<br>    cout &lt;&lt; ss.<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br>    string mac;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, mac, <span class="hljs-string">&#x27;.&#x27;</span>))<br>    &#123;<br>        cout &lt;&lt; mac &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string input;<br>    <span class="hljs-comment">// 在 windows 端输入 127.0.0.1 然后输入 ctrl+z ，再输入 enter</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, input, <span class="hljs-string">&#x27; &#x27;</span>))<br>    &#123;<br>        cout &lt;&lt; input &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 输出结果为 127 0 0 1 ；当标准输入接收为 eof 的时候就会返回 null</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// test1();</span><br>    <span class="hljs-built_in">test2</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h2><p>上面介绍完了lambda表达式的各个成分，其实很多部分和正常的函数没什么区别，其中最大的一个不同点就是捕获列表。我在刚开始用lambda表达式的时候，还一直以为这个没啥用，只是用一个 [] 来标志着这是一个lambda表达式。后来了解了才知道，原来这个捕获列表如此强大，甚至我觉得捕获列表就是lambda表达式的灵魂。下面先介绍几种常用的捕获方式。</p><p>[] 什么也不捕获，无法lambda函数体使用任何</p><p>[&#x3D;] 按值的方式捕获所有变量</p><p>[&amp;] 按引用的方式捕获所有变量</p><p>[&#x3D;, &amp;a] 除了变量a之外，按值的方式捕获所有局部变量，变量a使用引用的方式来捕获。这里可以按引用捕获多个，例如 [&#x3D;, &amp;a, &amp;b,&amp;c]。这里注意，如果前面加了&#x3D;，后面加的具体的参数必须以引用的方式来捕获，否则会报错。</p><p>[&amp;, a] 除了变量a之外，按引用的方式捕获所有局部变量，变量a使用值的方式来捕获。这里后面的参数也可以多个，例如 [&amp;, a, b, c]。这里注意，如果前面加了&amp;，后面加的具体的参数必须以值的方式来捕获。</p><p>[a, &amp;b] 以值的方式捕获a，引用的方式捕获b，也可以捕获多个。</p><p>[this] 在成员函数中，也可以直接捕获this指针，其实在成员函数中，[&#x3D;]和[&amp;]也会捕获this指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">5</span>;<br>    <br>    <span class="hljs-comment">// 按值来捕获</span><br>    <span class="hljs-keyword">auto</span> func1 = [a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;;<br>    <span class="hljs-built_in">func1</span>();<br><br>    <span class="hljs-comment">// 按值来捕获</span><br>    <span class="hljs-keyword">auto</span> func2 = [=] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;<br>    <span class="hljs-built_in">func2</span>();<br><br>    <span class="hljs-comment">// 按引用来捕获</span><br>    <span class="hljs-keyword">auto</span> func3 = [&amp;a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;;<br>    <span class="hljs-built_in">func3</span>();<br><br>    <span class="hljs-comment">// 按引用来捕获</span><br>    <span class="hljs-keyword">auto</span> func4 = [&amp;] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;<br>    <span class="hljs-built_in">func4</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编译器如何看待Lambda表达式"><a href="#编译器如何看待Lambda表达式" class="headerlink" title="编译器如何看待Lambda表达式"></a>编译器如何看待Lambda表达式</h2><p>我们把lambda表达式看成一个函数，那编译器怎么看待我们协的lambda呢？</p><p>其实，编译器会把我们写的lambda表达式翻译成一个类，并重载 operator()来实现。比如我们写一个lambda表达式为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> plus = [] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>那么编译器会把我们写的表达式翻译为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类名是我随便起的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;;<br><br>LambdaClass plus;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>调用的时候编译器会生成一个Lambda的对象，并调用opeartor ()函数。（备注：这里的编译的翻译结果并不和真正的结果完全一致，只是把最主要的部分体现出来，其他的像类到函数指针的转换函数均省略）</p><p>上面是一种调用方式，那么如果我们写一个复杂一点的lambda表达式，表达式中的成分会如何与类的成分对应呢？我们再看一个 值捕获 例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> plus = [=] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> x + y + a + b; &#125;;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>编译器的翻译结果为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LambdaClass</span>(<span class="hljs-type">int</span> xx, <span class="hljs-type">int</span> yy)<br>    : <span class="hljs-built_in">x</span>(xx), <span class="hljs-built_in">y</span>(yy) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x + y + a + b;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;<br><span class="hljs-function">LambdaClass <span class="hljs-title">plus</span><span class="hljs-params">(x, y)</span></span>;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>其实这里就可以看出，值捕获时，编译器会把捕获到的值作为类的成员变量，并且变量是以值的方式传递的。需要注意的时，如果所有的参数都是值捕获的方式，那么生成的operator()函数是const函数的，是无法修改捕获的值的，哪怕这个修改不会改变lambda表达式外部的变量，如果想要在函数内修改捕获的值，需要加上关键字 mutable。向下面这样的形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> plus = [=] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) <span class="hljs-keyword">mutable</span> -&gt; <span class="hljs-type">int</span> &#123; x++; <span class="hljs-keyword">return</span> x + y + a + b; &#125;;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="引用的方式捕获变量"><a href="#引用的方式捕获变量" class="headerlink" title="引用的方式捕获变量"></a>引用的方式捕获变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> plus = [&amp;] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> &#123; x++; <span class="hljs-keyword">return</span> x + y + a + b;&#125;;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>编译器的翻译结果为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LambdaClass</span>(<span class="hljs-type">int</span>&amp; xx, <span class="hljs-type">int</span>&amp; yy)<br>    : <span class="hljs-built_in">x</span>(xx), <span class="hljs-built_in">y</span>(yy) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        x++;<br>        <span class="hljs-keyword">return</span> x + y + a + b;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> &amp;x;<br>    <span class="hljs-type">int</span> &amp;y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以看到以引用的方式捕获变量，和值捕获的方式有3个不同的地方：</p><pre><code class="hljs">1. 参数引用的方式进行传递; 2. 引用捕获在函数体修改变量，会直接修改lambda表达式外部的变量；3. opeartor()函数不是const的。</code></pre><p>针对上面的集中情况，我们把lambda的各个成分和类的各个成分对应起来就是如下的关系:</p><p>捕获列表，对应LambdaClass类的private成员。</p><p>参数列表，对应LambdaClass类的成员函数的operator()的形参列表</p><p>mutable，对应 LambdaClass类成员函数 operator() 的const属性 ，但是只有在捕获列表捕获的参数不含有引用捕获的情况下才会生效，因为捕获列表只要包含引用捕获，那operator()函数就一定是非const函数。</p><p>返回类型，对应 LambdaClass类成员函数 operator() 的返回类型</p><p>函数体，对应 LambdaClass类成员函数 operator() 的函数体。</p><p>引用捕获和值捕获不同的一点就是，对应的成员是否为引用类型。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://en.cppreference.com/w/cpp/language/lambda">参考 cppreference</a></p><h1 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h1><p>1、引入 inline 关键字的原因<br>在 c&#x2F;c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。</p><p>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。</p><p>在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p><p>下面我们来看一个例子：</p><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">num_check</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (v % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;奇&quot;</span> : <span class="hljs-string">&quot;偶&quot;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02d   %s\n&quot;</span>, i, <span class="hljs-built_in">num_check</span>(i));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子就是标准的内联函数的用法，使用 inline 修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个 for 循环的内部任何调用 num_check(i) 的地方都换成了 (i%2&gt;0)?”奇”:”偶”，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。</p><p>2、inline使用限制</p><p>inline 的使用是有所限制的，inline 只适合涵数体内代码简单的函数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。</p><p>3、inline仅是一个对编译器的建议</p><p>inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</p><p>4、建议 inline 函数的定义放在头文件中</p><p>其次，因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。</p><p>因此，将内联函数的定义放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。</p><p>声明跟定义要一致：如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。</p><p>5、类中的成员函数与inline</p><p>定义在类中的成员函数默认都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;  &#125; <span class="hljs-comment">// 自动地成为内联函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 头文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br>&#125;<br> <br> <br><span class="hljs-comment">// 定义文件</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">A::Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>6、inline 是一种”用于实现的关键字”</p><p>关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。</p><p>如下风格的函数 Foo 不能成为内联函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>; <span class="hljs-comment">// inline 仅与函数声明放在一起</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>而如下风格的函数 Foo 则成为内联函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;&#125; <span class="hljs-comment">// inline 与函数定义体放在一起</span><br></code></pre></td></tr></table></figure><p>所以说，inline 是一种”用于实现的关键字”，而不是一种”用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++&#x2F;C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</p><p>7、慎用 inline</p><p>内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着”内联”这个关键字吗？<br>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。<br>如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p><p>以下情况不宜使用内联：<br>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。<br>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如”偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。</p><p>8、总结</p><p>内联函数并不是一个增强性能的灵丹妙药。只有当函数非常短小的时候它才能得到我们想要的效果；但是，如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大。<br>最令人烦恼的还是当编译器拒绝内联的时候。在老的实现中，结果很不尽人意，虽然在新的实现中有很大的改善，但是仍然还是不那么完善的。一些编译器能够足够的聪明来指出哪些函数可以内联哪些不能，但是大多数编译器就不那么聪明了，因此这就需要我们的经验来判断。如果内联函数不能增强性能，就避免使用它！</p><h2 id="面向对象设计的原则"><a href="#面向对象设计的原则" class="headerlink" title="面向对象设计的原则"></a>面向对象设计的原则</h2><p>面向对象设计（Object-Oriented Design，OOD）有许多原则和准则，下面是几个广为人知的重要原则：</p><ol><li><p>单一职责原则（Single Responsibility Principle，SRP）：<br>一个类应该只有一个引起它变化的原因。换句话说，一个类应该只有一个职责。这样可以提高类的可读性、可维护性和可测试性。</p></li><li><p>开放封闭原则（Open-Closed Principle，OCP）：<br>软件实体（类、模块、函数等）应该对扩展（变化）开放，而对修改关闭。这样可以保持系统的稳定性，同时方便添加新功能或修改现有功能。</p></li><li><p>里氏替换原则（Liskov Substitution Principle，LSP）：<br>子类对象应该能够替换其父类对象，并且程序不会产生错误或异常。这意味着子类应该遵循父类所定义的行为规范，而不改变父类的预期行为。</p></li><li><p>依赖倒置原则（Dependency Inversion Principle，DIP）：<br>高层模块不应该依赖于低层模块，而是应该依赖于抽象接口。通过依赖注入等方式，可以降低模块之间的耦合度，提高系统的可维护性和可测试性。</p></li><li><p>接口隔离原则（Interface Segregation Principle，ISP）：<br>客户端不应该依赖于它不需要的接口。一个类或模块只应该依赖于其需要的接口，避免对无用接口的依赖，从而减少耦合度。</p></li><li><p>迪米特法则（Law of Demeter，LoD）：<br>一个对象应该对其他对象有尽可能少的了解，也就是最小知道原则。对象之间的耦合越低，系统越灵活、可重用性越高。</p></li></ol><p>这些原则都是为了提高软件设计的质量和可维护性，通过降低耦合度、增加可复用性、提高扩展性等方面来实现优秀的面向对象设计。在实际应用中，根据具体情况和需求选择合适的原则，并结合设计模式等技术进行实践。</p><h2 id="c-中继承的特点"><a href="#c-中继承的特点" class="headerlink" title="c++中继承的特点"></a>c++中继承的特点</h2><p>C++ 中的继承是面向对象编程中的重要特性，它允许将一个类的特性和行为传递给另一个类，从而实现代码重用和组织。</p><p>C++ 中的继承具有以下几个特点：</p><ol><li><p>类的单继承和多继承：C++ 支持单继承和多继承。单继承是指一个类只有一个直接的父类，而多继承则是指一个类可以同时从多个父类继承属性和方法。多继承需要注意解决命名冲突等问题。</p></li><li><p>派生类增加新功能：通过继承，派生类可以获得基类的所有属性和方法，并且可以在此基础上添加自己的新功能。派生类可以添加新的成员函数，也可以覆盖（override）基类中的成员函数。</p></li><li><p>访问控制：C++ 中的继承也遵循访问控制规则，即公有继承、保护继承和私有继承。公有继承表示基类中的公有成员在派生类中仍然是公有的，保护继承表示基类中的公有成员在派生类中变为了保护成员，私有继承表示基类中的公有和保护成员在派生类中变为了私有成员。</p></li><li><p>构造函数和析构函数：C++ 中的构造函数和析构函数也可以被继承，派生类必须调用基类的构造函数来初始化从基类继承的成员变量和方法。析构函数的调用顺序与构造函数的调用顺序相反。</p></li><li><p>虚函数和多态：C++ 中的虚函数机制可以支持运行时多态。通过在基类中声明虚函数，并在派生类中覆盖它们，可以实现不同对象之间的动态绑定（dynamic binding）。这种特性可以方便地实现基于接口设计和实现等场景。</p></li></ol><p>总之，C++ 中的继承提供了一种强大的代码复用和组织机制，使得程序设计更加清晰、易于维护和扩展。但是，在使用继承时需要注意解决命名冲突、控制访问权限、避免继承深度过深等问题，以保证程序的正确性和可读性。</p><h2 id="类多继承需要注意什么"><a href="#类多继承需要注意什么" class="headerlink" title="类多继承需要注意什么"></a>类多继承需要注意什么</h2><p>在使用类多继承时，需要注意以下几点：</p><ol><li><p>命名冲突：多继承可能导致不同父类具有相同名称的成员（属性、方法等），这会引起命名冲突。为避免冲突，需要进行适当的命名空间管理或在派生类中使用完全限定名来引用成员。</p></li><li><p>虚函数与菱形继承问题：当存在多个父类时，并且其中某些类在继承关系中共享一个基类，就会出现所谓的菱形继承问题（也称菱形继承二义性）。例如，派生类 D 继承自两个基类 B 和 C，而 B 和 C 又都继承自基类 A。如果存在与 A 相关的虚函数，在 D 类中调用该虚函数可能会产生歧义。可以通过虚拟继承（virtual inheritance）来解决该问题，即在 B 和 C 继承 A 的地方使用 virtual 关键字。</p></li><li><p>父类构造函数调用：当一个类有多个父类时，需要确保每个父类的构造函数被正确调用来初始化它们的成员。在派生类的构造函数中，需要显式调用每个父类的构造函数，并按照正确的顺序传递参数。</p></li><li><p>类的设计复杂性：多继承可能引入更大的设计复杂性，增加代码的理解和维护难度。因此，在使用多继承时应慎重考虑，并遵循良好的设计原则，如单一职责原则、接口隔离原则等，以确保代码的可读性和可维护性。</p></li><li><p>合理使用多继承：多继承在某些情况下可以提供更灵活的设计方案，但也容易导致过度使用。应该评估是否真正需要多继承，以及是否可以通过其他方式（如组合、接口等）来达到相同的效果。</p></li></ol><p>总之，使用类多继承时需要注意处理命名冲突、避免菱形继承问题、正确调用父类构造函数，并合理设计和使用多继承，以确保代码的正确性、清晰性和可维护性。</p><h2 id="c-子类继承父类的过程中那些方法和成员变量不会被继承"><a href="#c-子类继承父类的过程中那些方法和成员变量不会被继承" class="headerlink" title="c++子类继承父类的过程中那些方法和成员变量不会被继承"></a>c++子类继承父类的过程中那些方法和成员变量不会被继承</h2><p>在 C++ 中，子类继承父类的过程中有一些方法和成员变量不会被继承，主要包括以下几种情况：</p><ol><li><p>父类的构造函数和析构函数：子类虽然可以继承父类的构造函数和析构函数，但并不是所有的都会被继承。例如，若父类中存在 private 型构造函数，则子类在继承时并不能直接调用该构造函数。</p></li><li><p>父类的赋值运算符（赋值操作符&#x3D;）: 子类继承父类时，父类中的赋值运算符不会被自动继承，需要手动定义子类中的赋值运算符。</p></li><li><p>父类中的 static 成员变量和静态方法：在子类中，static 成员变量和静态方法是属于父类并不会被子类继承。如果需要在子类中使用父类的 static 成员和静态方法，需要使用完全限定名来引用父类的成员。(但是在子类中是可以直接访问静态变量和静态方法的)</p></li><li><p>父类中的私有成员：由于私有成员只能被类本身访问，其他类不能访问私有成员。因此，子类无法继承父类中的私有成员，子类只能通过父类提供的公有接口或者受保护接口访问其私有成员。</p></li><li><p>父类的友元关系：子类一般不会继承父类中的友元关系，因为友元关系是建立在类之间的而非继承关系上。如果需要在子类中维护父类的友元关系，需要在子类中重新声明和定义相关的函数，并将其声明为友元函数。</p></li></ol><p>总之，子类继承父类时，虽然可以继承很多东西，但一些特殊的成员变量和方法并不会被自动继承。为了正确地继承和使用父类的成员，需要注意这些情况并适当地处理。</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式面试八股文</title>
    <link href="/2023/08/13/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/2023/08/13/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux中异常和软中断的区别"><a href="#Linux中异常和软中断的区别" class="headerlink" title="Linux中异常和软中断的区别"></a>Linux中异常和软中断的区别</h2><p>在Linux中，异常（Exception）和软中断（Soft Interrupt）是两种不同类型的中断机制。它们具有以下区别：</p><ul><li>引发条件：</li></ul><p>异常：异常是由CPU在执行指令过程中遇到错误或异常情况时触发的。例如，访问非法内存地址、除零错误等。<br>软中断：软中断是由软件编程请求触发的中断。程序员可以通过系统调用或软中断指令（如INT指令）在用户空间向内核发起软中断。</p><ul><li>处理方式：</li></ul><p>异常：当出现异常时，CPU会立即停止当前正在执行的指令，并转移到异常处理程序来处理异常情况。异常处理程序通常由操作系统内核提供。<br>软中断：软中断通常是由用户空间的应用程序触发的，并且在内核空间中执行相应的软中断处理程序。软中断允许应用程序请求特定的内核功能或服务。</p><ul><li>使用场景：</li></ul><p>异常：异常通常用于处理严重的错误或异常情况，如硬件错误、内存保护违规等。它们是由操作系统内核处理的一种低级事件。<br>软中断：软中断常用于应用程序和内核之间的通信，以及请求特定的内核服务。例如，文件系统操作、网络操作等都可以通过软中断来实现。<br>总之，异常和软中断是两种不同的中断机制，在引发条件、处理方式和使用场景等方面存在明显的区别。异常通常由硬件触发，处理系统底层错误；而软中断是由用户空间程序请求，并用于与内核进行交互和执行特定的内核功能。</p><h2 id="TCP的可靠性体现在那几个方面"><a href="#TCP的可靠性体现在那几个方面" class="headerlink" title="TCP的可靠性体现在那几个方面"></a>TCP的可靠性体现在那几个方面</h2><p>TCP（传输控制协议）是一种在计算机网络中常用的传输协议，它提供了可靠的数据传输服务。TCP的可靠性体现在以下几个方面：</p><ol><li>确认和重传：TCP使用确认机制来确保数据的可靠传输。接收方在成功接收到数据后会发送确认消息给发送方，如果发送方在一定时间内没有收到确认消息，就会重新发送数据。</li><li>滑动窗口：TCP使用滑动窗口机制来控制发送方发送数据的速率。接收方会告诉发送方自己的接收窗口大小，发送方根据接收窗口的大小来发送数据，确保接收方能够及时处理接收到的数据。</li><li>流量控制：TCP使用流量控制机制来控制数据的发送速率，以防止发送方发送过多的数据导致接收方无法及时处理。接收方会通过发送窗口的大小来告诉发送方自己的接收能力，发送方根据接收窗口的大小来控制发送速率。</li><li>拥塞控制：TCP使用拥塞控制机制来避免网络拥塞。当网络出现拥塞时，TCP会减少发送速率，以降低网络负载，从而保证数据的可靠传输。</li></ol><p>综上所述，TCP通过确认和重传、滑动窗口、流量控制和拥塞控制等机制，提供了可靠的数据传输服务，确保数据能够按照正确的顺序、完整地传输到目的</p><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><p>进程（Process）和线程（Thread）是操作系统中的两个重要概念，它们有以下区别：</p><ol><li><p>定义：进程是计算机中正在运行的程序的实例。它包含了程序代码、数据以及程序执行所需的资源。而线程是进程中的一个执行单元，是进程的子任务。一个进程可以有多个线程。</p></li><li><p>资源关系：每个进程都有独立的内存空间和系统资源，如文件句柄、网络连接等。线程与所属进程共享相同的内存空间和系统资源。</p></li><li><p>并发性：不同的进程之间是并发执行的，它们可以同时运行在不同的CPU核心上。而线程是在进程内部并发执行的，多个线程共享进程的资源，可以在同一时间片内交替执行。</p></li><li><p>调度和切换：进程是操作系统进行调度和资源分配的基本单位。在进程切换时，需要保存和恢复进程的上下文信息，开销较大。线程则可以在同一进程内轻量级地进行切换，开销较小。</p></li><li><p>通信和同步：不同进程之间的通信需要使用特定的机制，如管道、消息队列、共享内存等。而线程之间可以直接通过共享内存进行通信，也可以使用锁、信号量等同步机制实现线程间的协调与同步。</p></li><li><p>稳定性和可靠性：一个进程的崩溃通常不会影响其他进程的正常运行。而一个线程的崩溃可能导致整个进程的崩溃。</p></li></ol><p>总的来说，进程和线程都是用于实现并发执行的机制，但它们在资源管理、并发性、调度和切换、通信和同步等方面有着不同的特点和应用场景。选择使用进程还是线程取决于具体的需求和设计考虑。</p><h2 id="进程间通信的方式有哪些"><a href="#进程间通信的方式有哪些" class="headerlink" title="进程间通信的方式有哪些"></a>进程间通信的方式有哪些</h2><p>进程间通信（Inter-Process Communication，简称IPC）是指不同进程之间进行数据交换和共享信息的机制。常见的进程间通信方式包括：</p><ol><li><p>管道（Pipe）：管道是一种单向通信方式，可以在具有亲缘关系的父子进程之间进行通信。其中，有名管道通过文件系统进行命名，使得无关进程也可以进行通信。</p></li><li><p>共享内存（Shared Memory）：共享内存允许多个进程访问同一块物理内存区域，进程可以直接读写共享内存中的数据，因此速度较快。但需要额外的同步机制来保证数据的一致性。</p></li><li><p>信号量（Semaphore）：信号量是一种计数器，用于控制多个进程对共享资源的访问。进程通过对信号量的操作来实现互斥和同步。</p></li><li><p>消息队列（Message Queue）：消息队列是一种通过消息传递进行通信的方式。进程可以将消息发送到队列，其他进程则从队列中接收消息。消息队列支持异步通信和消息的优先级排序。</p></li><li><p>套接字（Socket）：套接字是一种网络编程的通信机制，可以在不同主机之间的进程进行通信。通过套接字，可以进行跨网络的进程间通信。</p></li><li><p>信号（Signal）：信号是一种异步通信机制，用于通知进程发生了某个事件。进程可以注册信号处理函数来捕获和处理信号。</p></li><li><p>文件（File）：进程可以通过读写同一个文件来进行通信。通过对文件的加锁机制，可以实现进程之间的互斥和同步。</p></li></ol><p>这些通信方式各有特点，适用于不同的场景和需求。在选择进程间通信方式时，需要考虑数据量、效率、可靠性、同步与并发控制的需求，以及操作系统和编程语言的支持性等因素。</p><h2 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h2><p>线程间通信（Inter-Thread Communication，简称ITC）是指不同线程之间进行数据交换和共享信息的机制。常见的线程间通信方式包括：</p><ol><li><p>共享内存（Shared Memory）：多个线程可以访问和修改共享的内存区域来进行通信。通过在共享内存中读写数据，线程可以进行信息的传递和共享。</p></li><li><p>互斥锁（Mutex）：互斥锁用于保护共享资源的访问，只允许一个线程访问共享资源，其他线程需要等待。线程在访问共享资源前获取互斥锁，使用完后释放互斥锁。</p></li><li><p>条件变量（Condition Variable）：条件变量用于线程间的同步和通知机制。一个线程可以等待条件变量的满足，而另一个线程可以通过触发条件变量来通知等待的线程。</p></li><li><p>信号量（Semaphore）：信号量是一种计数器，控制对共享资源的访问。线程可以通过对信号量的操作来实现互斥和同步，例如使用信号量来限制并发线程数量或控制资源的可用性。</p></li><li><p>屏障（Barrier）：屏障用于确保多个线程在达到某个点之前互相等待。当所有线程都达到屏障后，它们可以继续执行。</p></li><li><p>队列（Queue）：线程可以使用队列来实现异步消息传递和共享数据。一个线程可以将数据放入队列，而其他线程可以从队列中取出数据。</p></li><li><p>数据锁机制（Data Locking）：线程可以使用锁机制，如读写锁（Read-Write Lock）或自旋锁（Spinlock），来保护对共享数据的访问。</p></li></ol><p>选择适当的线程间通信方式取决于具体的场景和需求。需要考虑线程之间数据共享的安全性、同步与并发控制的需求，以及编程语言和操作系统提供的支持。合理使用线程间通信机制可以实现线程的协调合作和共享资源的高效利用。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供全局访问该实例的方式。单例模式常用于需要全局唯一性的对象，例如日志记录器、数据库连接池、线程池等。</p><p>要实现单例模式，一般需要满足以下几个条件：</p><ol><li><p>私有化构造函数：将类的构造函数声明为私有，这样外部无法直接通过构造函数创建类的实例。</p></li><li><p>静态成员变量：在类的内部定义一个静态成员变量，用于保存类的唯一实例。</p></li><li><p>静态成员函数：提供一个静态成员函数用于获取类的实例。该函数负责创建实例（如果实例不存在），并返回实例的引用。</p></li></ol><p>下面是一个简单的示例代码，展示了如何实现单例模式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* instance;<br><br>    <span class="hljs-comment">// 将构造函数和析构函数声明为私有，禁止外部直接创建和销毁实例</span><br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 提供静态成员函数获取实例</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> *instance;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 在类外初始化静态成员变量</span><br>Singleton* Singleton::instance = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p>在上述示例中，Singleton类通过将构造函数和析构函数声明为私有，确保其他代码无法直接通过构造函数创建实例或销毁实例。而通过getInstance静态成员函数来获得Singleton类的唯一实例，如果实例不存在则创建实例并返回。</p><p>使用单例模式时要注意以下几点：</p><ul><li><p>线程安全：在多线程环境下，需要考虑并发访问的安全问题。可以通过加锁机制或双重检查锁定等方式来保证线程安全性。</p></li><li><p>生命周期管理：单例模式中的实例一般在整个应用程序生命周期中存在，因此需要注意内存泄漏和资源释放的问题。</p></li><li><p>测试难度：由于单例类的全局可访问性，可能会对测试造成困扰。在编写单元测试时，需要考虑如何创建和销毁单例实例，以及如何隔离单例对其他代码的影响。</p></li></ul><p>总结来说，单例模式通过限制一个类只能有一个实例，并提供全局访问的方式，可以满足某些场景下对对象唯一性的需求。然而，它也容易导致全局状态和耦合性增加，因此在使用时需要慎重权衡。</p><h2 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h2><p>空闲链表法（Free List）是一种内存管理的数据结构和算法，用于管理可用的内存块。在空闲链表法中，内存块被组织成一个链表，链表中的每个节点表示一个可用的内存块。</p><p>以下是空闲链表法的基本原理和操作：</p><ul><li><p>初始化：在初始时，整个可用的内存空间被看作一个大的连续内存块，所有的内存块都被链接到一个空闲链表中。</p></li><li><p>分配：当需要分配内存时，从空闲链表头部取出一个足够大的内存块，并将其分配给请求的进程或线程。若没有足够大的内存块，则可能需要合并多个小的内存块，或者从操作系统申请更多的内存空间。</p></li><li><p>释放：当内存块不再被使用时，将其添加到空闲链表中，以便后续的内存分配可以利用该空闲块。为了避免内存碎片化，可能需要对相邻的空闲块进行合并，形成一个更大的块。</p></li><li><p>碎片处理：随着内存的分配和释放，可能会导致内存碎片的产生。内存碎片是指一些小而不连续的空闲内存块。为了优化内存的利用，可以采取碎片整理算法，如紧凑（Compaction）或分区（Partitioning）等，来合并和重组空闲块，以减少碎片化。</p></li></ul><p>空闲链表法在许多内存分配算法中被使用，例如动态内存分配算法中的首次适应（First Fit）、循环适应（Next Fit）和最佳适应（Best Fit）等。通过使用空闲链表法，可以有效地管理可用内存块，并提供高效的内存分配和释放操作。</p><h2 id="c-中智能指针"><a href="#c-中智能指针" class="headerlink" title="c++中智能指针"></a>c++中智能指针</h2><p>在C++中，智能指针是一种用于管理动态分配的内存资源的类模板。它们提供了自动化的内存管理，帮助开发人员避免内存泄漏和悬空指针等问题。</p><p>C++标准库提供了以下三种类型的智能指针：</p><ul><li><p>std::unique_ptr&lt;T&gt;：独占所有权的智能指针。每个std::unique_ptr实例可以拥有一个动态分配的对象，并负责在其生命周期结束时自动释放该对象。它不能被复制，但可以通过std::move进行转移所有权。</p></li><li><p>std::shared_ptr&lt;T&gt;：共享所有权的智能指针。std::shared_ptr可以多个实例共享同一块内存资源，通过引用计数来追踪资源的使用情况。当最后一个std::shared_ptr析构时，关联的内存资源会被释放。</p></li><li><p>std::weak_ptr&lt;T&gt;：弱引用智能指针。std::weak_ptr用于解决std::shared_ptr可能导致的循环引用问题。std::weak_ptr可以从一个std::shared_ptr或另一个std::weak_ptr创建，但它不会增加引用计数。通过std::weak_ptr可以检查关联资源是否仍然存在，并在需要时获取一个有效的std::shared_ptr。</p></li></ul><p>使用智能指针可以帮助开发人员更好地管理动态内存分配。它们自动处理释放内存的过程，避免了手动调用delete或free的繁琐工作，并提供更安全和方便的内存管理机制。然而，需要注意使用适当的智能指针类型以避免循环引用和资源泄漏等问题。此外，对于非动态分配的对象或静态局部变量，不应使用智能指针。</p><h2 id="new、delete-和-malloc、free-的区别"><a href="#new、delete-和-malloc、free-的区别" class="headerlink" title="new、delete 和 malloc、free 的区别"></a>new、delete 和 malloc、free 的区别</h2><p>C++ 中的 new 和 delete，以及 C 语言中的 malloc 和 free 都是用于动态分配和释放内存的操作。它们之间的区别如下：</p><ol><li><p>使用方式：new 和 delete 是 C++ 中的关键字，而 malloc 和 free 是 C 语言中的库函数。</p></li><li><p>类型安全：new 和 delete 是类型安全的，在分配和释放内存时会根据对象的类型进行构造和析构函数的调用。而 malloc 和 free 则不会调用对象的构造和析构函数，只是简单地分配和释放内存块。</p></li><li><p>内存大小：malloc 函数接受一个参数，表示要分配的内存块的大小（以字节为单位），返回一个指向该内存块起始地址的指针。而 new 关键字可以根据类型自动计算所需的内存大小，并返回指向分配的对象的指针。</p></li><li><p>异常处理：new 操作符在分配内存失败时会抛出 std::bad_alloc 异常，可以通过捕获异常来进行错误处理。而 malloc 函数在分配内存失败时会返回 NULL，需要手动检查返回值是否为 NULL 来判断是否分配成功。</p></li><li><p>用途：new 和 delete 主要用于动态分配和释放对象，它们会调用对象的构造函数和析构函数。而 malloc 和 free 则更通用，可以用于分配和释放任意大小的内存块，但不会调用对象的构造和析构函数。</p></li></ol><p>总的来说，new 和 delete 是 C++ 提供的更加类型安全、功能更强大的动态内存管理方式，推荐在 C++ 中使用。而在 C 语言中，则使用 malloc 和 free 更为常见。如果你在 C++ 中使用了 malloc 来分配内存，应当使用 free 来释放内存；同样，如果在 C 语言中使用了 new 来分配内存，应当使用 delete 来释放内存会导致未定义行为。</p><h2 id="简述中断处理函数的顶半部、底半部机制"><a href="#简述中断处理函数的顶半部、底半部机制" class="headerlink" title="简述中断处理函数的顶半部、底半部机制"></a>简述中断处理函数的顶半部、底半部机制</h2><p>为了平衡中断处理程序时间要求短和工作量要大的问题，linux将中断处理程序分为顶半部(top half)和底半部(bottom half)</p><ul><li>顶半部完成的一般是紧急的硬件操作，一般包括读取寄存的中断状态，清除中断标志，将底半部处理程序挂到底半部的执行队列中去</li><li>底半部执行大部分的耗时操作，并且可以被新的中断打断</li></ul><h2 id="简述-DMA-原理"><a href="#简述-DMA-原理" class="headerlink" title="简述 DMA 原理"></a>简述 DMA 原理</h2><p>DMA（Direct Memory Access，直接内存访问）是一种用于数据传输的技术，在计算机系统中用于高效地实现设备之间的数据传输，减轻了中央处理器的负担。其工作原理如下：</p><ol><li><p>设置DMA控制器：首先，需要通过编程将DMA控制器配置为所需的传输模式。这包括设置传输的源地址（输入数据所在的设备或内存区域）、目标地址（输出数据所在的设备或内存区域）、传输数据的长度等。</p></li><li><p>初始化传输请求：当需要进行数据传输时，设备（如硬盘、网络适配器等）向DMA控制器发送传输请求。DMA控制器接收到请求后，开始执行数据传输操作。</p></li><li><p>中断处理：如果需要在数据传输完成后进行相应的处理，可以启用DMA中断功能。在数据传输完成之后，DMA控制器会发出中断信号，通知CPU进行相应的处理。</p></li><li><p>DMA控制器执行传输：DMA控制器使用总线嗅探技术，具有直接访问系统总线的能力。它直接控制总线并与主内存进行数据交换，绕过了中央处理器。DMA控制器逐个读取源地址中的数据，并将其传输到目标地址。它可以一次性传输一块连续的数据，也可以分多次传输。</p></li><li><p>完成传输：当DMA控制器完成数据传输后，它会向设备发送完成信号，并将总线控制权交还给中央处理器。</p></li></ol><p>通过使用DMA，数据传输可以在不占用中央处理器过多时间的情况下进行，从而提高整个系统的效率。DMA技术广泛应用于许多设备之间的数据传输，如硬盘传输、图形卡传输等，以提高数据传输的速度和效率。</p><h2 id="总线地址、物理地址、虚拟地址的区别是什么"><a href="#总线地址、物理地址、虚拟地址的区别是什么" class="headerlink" title="总线地址、物理地址、虚拟地址的区别是什么?"></a>总线地址、物理地址、虚拟地址的区别是什么?</h2><p>总线地址、物理地址和虚拟地址是三种不同的地址概念。</p><ol><li><p>总线地址(Bus Address)：指的是设备直接访问主存时使用的地址，也称为物理地址（Physical Address）。这个地址是硬件直接使用的，通常可以看作一个机器的绝对内存地址。在总线上传输的都是总线地址。</p></li><li><p>物理地址（Physical Address）：指的是内存中实际的地址，用来寻址系统中的物理内存。当CPU需要读取或写入内存时，就会将逻辑地址转换为物理地址。物理地址是常规的、实际的内存地址，是由硬件（如MMU）负责生成的，与CPU的处理器相关。</p></li><li><p>虚拟地址（Virtual Address）：指的是应用程序使用的地址，每个进程都有自己的虚拟地址空间，程序可以使用虚拟地址来访问内存，而不必关心内存的物理位置。操作系统负责将虚拟地址映射到物理地址上，使得多个进程之间的地址空间互相独立。虚拟地址是逻辑地址，即在交给操作系统之前，程序员编写的地址。</p></li></ol><p>总的来说，总线地址和物理地址是一回事，它们表示的是硬件直接使用的地址，反映的是内存的实际位置。而虚拟地址则是由操作系统负责管理的，它与物理地址之间需要进行映射，反映的是应用程序的逻辑地址。虚拟地址的使用可以增加系统的安全性，方便内存管理，也能有效避免不同进程之间的空间冲突。</p><h2 id="在嵌入式系统中-NOR-Flash和-NAND-Flash的最大区别是什么"><a href="#在嵌入式系统中-NOR-Flash和-NAND-Flash的最大区别是什么" class="headerlink" title="在嵌入式系统中, NOR Flash和 NAND Flash的最大区别是什么?"></a>在嵌入式系统中, NOR Flash和 NAND Flash的最大区别是什么?</h2><p>在嵌入式系统中，NOR Flash和NAND Flash是两种常见的非易失性存储器类型，它们有以下最大区别：</p><ol><li><p>存储单元组织方式：NOR Flash和NAND Flash的存储单元组织方式不同。NOR Flash以字节为单位进行读取和编程，具有随机访问性能，类似于传统的存储器结构。而NAND Flash以页（通常为4KB或8KB）为单位进行读取和编程，只能按块（通常为64KB或128KB）进行擦除，读取和编程速度较慢。</p></li><li><p>读取速度：由于存储单元组织方式的不同，NOR Flash具有快速的随机读取速度，适用于执行代码和存储程序的应用。而NAND Flash的读取速度相对较慢，适用于大容量数据存储和传输的应用。</p></li><li><p>擦除方式：NOR Flash可以按字节擦除，擦除操作可以直接修改存储的数据。而NAND Flash只能按块擦除，且擦除操作会将整个块的数据全部擦除，需要重新编程写入。</p></li><li><p>寿命：NOR Flash具有较长的擦写寿命，通常可以达到10万次或更多，适用于频繁擦写的应用，如代码存储。而NAND Flash的擦写寿命较短，通常在数千到数万次之间，适用于存储静态或不频繁更新的大容量数据。</p></li><li><p>成本：由于制造工艺和性能差异，NOR Flash相对于NAND Flash来说成本较高。NOR Flash常用于较小容量的应用，而NAND Flash常用于大容量的嵌入式存储器。</p></li></ol><p>综上所述，NOR Flash适用于需要快速随机读取和频繁擦写的应用，如执行代码和存储程序；而NAND Flash适用于大容量数据存储和传输的应用，如存储媒体文件和固件升级。选择合适的存储器类型需要根据具体的应用需求和性能要求进行评估。</p><h2 id="ARM架构的嵌入式处理器内部常用到哪些片内总线"><a href="#ARM架构的嵌入式处理器内部常用到哪些片内总线" class="headerlink" title="ARM架构的嵌入式处理器内部常用到哪些片内总线?"></a>ARM架构的嵌入式处理器内部常用到哪些片内总线?</h2><p>ARM架构的嵌入式处理器内部常用到以下几种片内总线：</p><ol><li><p>系统总线（System Bus）：系统总线是连接处理器核心、高速缓存和内存控制器等关键组件的主要总线。它负责处理器核心与其他模块之间的数据传输，包括指令读取、数据读写等操作。</p></li><li><p>AMBA总线：AMBA（Advanced Microcontroller Bus Architecture）是一种开放的、标准化的总线架构，常用于ARM架构的嵌入式系统中。AMBA总线包括高级外设总线（Advanced Peripheral Bus，APB）和高级高性能总线（Advanced High-performance Bus，AHB）。APB总线用于连接低带宽的外设，AHB总线则用于连接高带宽的内存和高性能外设。</p></li><li><p>AXI总线：AXI（Advanced eXtensible Interface）是一种高性能、高带宽的总线接口标准，常用于连接多个互连模块和处理器核心。AXI总线具有多个通道和支持乱序传输的特性，可以实现高效的数据传输和片内通信。</p></li><li><p>DMA总线：DMA（Direct Memory Access）总线是一种用于数据直接传输的总线，可以实现处理器与外设直接进行数据交换。通过使用DMA总线，可以减轻处理器核心的负载，提高数据传输的效率。</p></li></ol><p>这些片内总线在嵌入式处理器内部扮演着关键的角色，用于连接处理器核心、高速缓存、内存控制器和外设等组件，实现数据的传输和通信。它们的设计目标是提供高性能、低功耗、可扩展性和灵活性，以满足嵌入式系统对数据交换的需求。</p><h2 id="ADC芯片的作用是什么-如果用ADC对一个10kHz的正弦波采样，则ADC的采样率至少为多少才能保证采样数据能还原波形-10kHz的正弦波与10kHz的方波其频率成分主要差异是什么"><a href="#ADC芯片的作用是什么-如果用ADC对一个10kHz的正弦波采样，则ADC的采样率至少为多少才能保证采样数据能还原波形-10kHz的正弦波与10kHz的方波其频率成分主要差异是什么" class="headerlink" title="ADC芯片的作用是什么?如果用ADC对一个10kHz的正弦波采样，则ADC的采样率至少为多少才能保证采样数据能还原波形?10kHz的正弦波与10kHz的方波其频率成分主要差异是什么?"></a>ADC芯片的作用是什么?如果用ADC对一个10kHz的正弦波采样，则ADC的采样率至少为多少才能保证采样数据能还原波形?10kHz的正弦波与10kHz的方波其频率成分主要差异是什么?</h2><p>ADC芯片全称为模数转换器（Analog-to-digital Converter），主要作用是将模拟信号转换成数字信号。在采集模拟信号时，需要将其转换成数字信号，以便于处理、存储和传输。ADC芯片能够将模拟信号根据一定的采样率转换成数字信号，并输出给微处理器或其他数字电路进行后续处理。</p><p>如果要对一个10kHz的正弦波进行采样，则需要至少满足奈奎斯特采样定理（Nyquist Sampling Theorem）。奈奎斯特定理指出，当采样率大于等于信号最高频率的两倍时，采集的离散信号才能还原为原始模拟信号。因此，对于10kHz的正弦波，其最高频率为5kHz，所以采样率至少需为10kHz × 2 &#x3D; 20kHz 才能保证采样数据能还原波形。</p><p>对于10kHz的正弦波和10kHz的方波，它们频率成分主要的差异在于频谱上的差异。正弦波的频谱是单峰的，而方波的频谱是多峰的，在频谱上具有更丰富的谐波成分。这也意味着方波包含更多高频成分，需要更高的采样率才能完整地还原波形。</p><h2 id="简述处理器中MMU单元的作用"><a href="#简述处理器中MMU单元的作用" class="headerlink" title="简述处理器中MMU单元的作用"></a>简述处理器中MMU单元的作用</h2><p>MMU（Memory Management Unit）是处理器中的一个关键组件，主要负责将虚拟地址转换为物理地址。它在操作系统的协助下，实现了虚拟内存的管理和地址映射，提供了一种抽象的内存访问方式。</p><p>MMU的主要作用有以下几个方面：</p><ol><li><p>虚拟内存管理：MMU通过将虚拟地址转换为物理地址，使得每个进程都能够拥有独立的地址空间。通过虚拟内存技术，系统可以更有效地利用物理内存资源，同时保护不同进程的内存数据。</p></li><li><p>地址映射：MMU根据页表或段表等数据结构，将虚拟地址映射到物理内存的对应位置。这样，当处理器访问虚拟地址时，MMU会自动进行地址转换，使得处理器看到的是对应的物理地址。</p></li><li><p>内存保护：MMU通过设置访问权限位，可以对不同的内存区域进行保护。例如，禁止某些进程访问其他进程的内存空间，或只允许只读访问某些内存区域，以增强系统的安全性和稳定性。</p></li><li><p>缓存管理：MMU还负责处理处理器与高速缓存之间的数据一致性问题。当虚拟地址映射到物理地址发生变化时，MMU会通知缓存进行相应的更新操作，以保证数据的一致性。</p></li></ol><p>总之，MMU在处理器中扮演着重要的角色，它通过实现虚拟内存管理和地址转换等功能，为系统提供了更高效的内存访问方式，并对内存进行保护和缓存管理，提升系统的性能和安全性。</p><h2 id="linux设备驱动程序主要分为哪几类，各自用于哪些设备"><a href="#linux设备驱动程序主要分为哪几类，各自用于哪些设备" class="headerlink" title="linux设备驱动程序主要分为哪几类，各自用于哪些设备?"></a>linux设备驱动程序主要分为哪几类，各自用于哪些设备?</h2><p>Linux设备驱动程序主要分为以下几类：</p><ol><li><p>字符设备驱动程序：这种类型的驱动程序用于管理字符设备，如串口、终端、打印机、音频等。它们以字节数组（即字符流）的形式进行 I&#x2F;O 操作。</p></li><li><p>块设备驱动程序：这种类型的驱动程序用于管理块设备，如硬盘、U盘、固态硬盘等。块设备是由固定大小的块组成，每个块都有独立的读&#x2F;写操作。</p></li><li><p>网络设备驱动程序：这种类型的驱动程序管理网络设备，如网卡和无线网卡等。它们提供了基本的网络协议栈和驱动程序接口，使得用户程序可以通过接口与网络设备进行通信。</p></li><li><p>USB 设备驱动程序：这种类型的驱动程序用于管理 USB 设备。USB 设备通常包括鼠标、键盘、摄像头、打印机等外部设备。</p></li><li><p>视频设备驱动程序：这种类型的驱动程序用于管理视频设备，如摄像头、监视器等。它们负责从摄像头等设备中读取图像数据，并将其转换成可用的视频数据格式。</p></li></ol><p>除了上述列举的几类外，还有一些特殊的设备驱动程序，如声卡驱动程序、蓝牙驱动程序、输入设备驱动程序等。这些驱动程序都有各自的特定功能，都是 Linux 系统中不可缺少的一部分。</p><h2 id="通过宏定义实现一个32bit数据的大小端转换"><a href="#通过宏定义实现一个32bit数据的大小端转换" class="headerlink" title="通过宏定义实现一个32bit数据的大小端转换"></a>通过宏定义实现一个32bit数据的大小端转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SWAP_32BII(x) (((x)&amp;0xFF000000) &gt;&gt; 24) | (((x)&amp;0x00FF0000) &gt;&gt; 8) | (((x)&amp;0x0000FF00) &lt;&lt; 8) | (((x)&amp;0x000000FF) &lt;&lt; 24)</span><br></code></pre></td></tr></table></figure><h2 id="操作系统通过何种数据结构维护进程-通过哪些算法调度进程"><a href="#操作系统通过何种数据结构维护进程-通过哪些算法调度进程" class="headerlink" title="操作系统通过何种数据结构维护进程?通过哪些算法调度进程?"></a>操作系统通过何种数据结构维护进程?通过哪些算法调度进程?</h2><p>操作系统通过进程控制块（Process Control Block，PCB）数据结构来维护进程。每个正在运行或等待执行的进程都有一个对应的PCB。</p><p>PCB是一个包含了关于进程信息的数据结构，用于操作系统管理和控制进程的执行。它通常包含以下信息：</p><ol><li>进程标识符（Process ID，PID）：唯一标识一个进程的数字。</li><li>程序计数器（Program Counter，PC）：记录了当前进程下一条要执行的指令的内存地址。</li><li>寄存器集合：保存了当前进程的寄存器状态，包括通用寄存器、程序状态字等。</li><li>进程状态：记录了进程的当前状态，例如新建、运行、就绪、阻塞、终止等。</li><li>内存管理信息：包括进程的内存分配情况、页表或段表等。</li><li>资源占用情况：记录了进程所占用的资源，如文件描述符、打开的文件列表、分配的内存等。</li><li>作业属性：包括进程的优先级、调度参数等。</li></ol><p>除了PCB之外，操作系统还使用调度算法来管理和调度进程的执行。调度算法决定了在给定时间点上应该运行哪个进程、如何分配CPU时间片、如何处理优先级等。</p><p>常见的调度算法包括：</p><ol><li>先来先服务（First-Come, First-Served，FCFS）：按照进程到达的顺序进行调度。</li><li>最短作业优先（Shortest Job Next，SJN）：选择估计运行时间最短的进程进行调度。</li><li>时间片轮转（Round Robin，RR）：每个进程在一个固定的时间片内运行，超过时间片后切换到下一个进程。</li><li>优先级调度（Priority Scheduling）：根据进程优先级确定进程的执行顺序。</li><li>多级反馈队列调度（Multilevel Feedback Queue Scheduling）：根据进程优先级和历史行为将进程分配到不同的队列，并按照一定的规则在队列之间进行调度。</li></ol><p>这些调度算法可以根据实际场景和需求进行选择和组合，以实现不同的调度策略。</p><h2 id="什么是进程下文切换-什么是中断上下文切换"><a href="#什么是进程下文切换-什么是中断上下文切换" class="headerlink" title="什么是进程下文切换?什么是中断上下文切换?"></a>什么是进程下文切换?什么是中断上下文切换?</h2><p>进程上下文切换和中断上下文切换是操作系统中两个重要的概念。</p><ol><li><p>进程上下文切换（Process Context Switching）：<br>进程上下文切换是指在多任务操作系统中，从一个正在运行的进程切换到另一个进程时，保存当前进程的执行状态并加载下一个进程的执行状态的过程。当操作系统决定要切换到另一个进程时，它会保存当前进程的寄存器状态、程序计数器等信息到该进程的PCB中，并加载下一个进程的相关信息到寄存器、程序计数器等，然后开始执行下一个进程。进程上下文切换常见于多核或单核多线程的系统中，以实现并行执行多个进程或线程，从而提高系统的吞吐量和响应性能。</p></li><li><p>中断上下文切换（Interrupt Context Switching）：<br>中断上下文切换是指当处理器接收到中断请求时，当前正在执行的指令被中断并切换到处理中断过程的上下文的过程。当发生硬件中断（如设备IO完成、定时器中断等）或软件中断（如系统调用、异常等）时，当前的指令执行被暂停，处理器从用户模式切换到内核模式，并执行与中断相关的处理程序。中断上下文包含了中断处理程序执行所需的寄存器状态、程序计数器等信息。当中断处理程序执行完毕后，处理器恢复到被中断的指令位置，继续执行原来的进程。</p></li></ol><p>进程上下文切换和中断上下文切换是操作系统实现多任务和中断处理的重要机制。它们涉及到保存和恢复进程或中断处理程序的执行状态，以有效地切换和调度不同的任务和中断，并保证系统在多个任务或中断之间正确地切换和执行。上下文切换的开销较大，因此在设计系统时需要合理考虑上下文切换的频率和影响，以提高系统的性能和效率。</p><h2 id="linux用户空间和内核通信的方式有哪些"><a href="#linux用户空间和内核通信的方式有哪些" class="headerlink" title="linux用户空间和内核通信的方式有哪些?"></a>linux用户空间和内核通信的方式有哪些?</h2><p>在Linux系统中，用户空间和内核之间可以通过以下几种方式进行通信：</p><ol><li><p>系统调用（System Calls）：<br>用户空间程序可以通过系统调用向内核发起请求以执行特权操作。系统调用是一组由操作系统提供的函数，允许用户空间程序访问内核功能。例如，读写文件、创建进程、网络通信等都是通过系统调用来完成的。</p></li><li><p>文件操作：<br>内核将文件抽象为文件描述符，并通过文件描述符进行用户空间和内核之间的通信。用户空间程序可以通过打开文件、读取文件、写入文件等操作来与内核进行交互。这种通信方式常用于IPC（进程间通信）机制中的管道（pipe）、命名管道（named pipe）、套接字（socket）等。</p></li><li><p>proc文件系统：<br>proc文件系统是一种特殊的虚拟文件系统，它允许用户空间程序通过读取和写入特定的文件来与内核进行通信。用户空间可以通过读取&#x2F;proc目录下的文件获取系统信息、进程信息等，也可以通过写入某些文件来修改内核参数。</p></li><li><p>sysfs文件系统：<br>sysfs文件系统提供了一种以文件形式表示设备和内核对象状态的机制。用户空间程序可以通过读取和写入sysfs中的文件来与内核进行通信，例如查看和修改设备属性。</p></li><li><p>netlink套接字（Netlink Socket）：<br>netlink是一种用于内核与用户空间进程之间进行通信的机制。用户空间程序可以创建netlink套接字，并通过发送和接收消息来与内核进行交互。它常被用于网络配置、路由管理等功能。</p></li></ol><p>这些方式提供了不同的方式供用户空间和内核进行通信，用户可以根据需要选择适合的通信方式来实现特定的功能。不同通信方式有各自的特点和适用场景，需要根据具体情况进行选择。</p><h2 id="分析下面代码的执行结果"><a href="#分析下面代码的执行结果" class="headerlink" title="分析下面代码的执行结果"></a>分析下面代码的执行结果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">signed</span> <span class="hljs-type">char</span> ch = <span class="hljs-number">129</span>;<br>cout &lt;&lt; (<span class="hljs-type">int</span>)ch &lt;&lt; endl;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ch2 = <span class="hljs-number">256</span>;<br>cout &lt;&lt; (<span class="hljs-type">int</span>)ch2 &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>-127<br>0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">6</span>, y = <span class="hljs-number">5</span>, z = <span class="hljs-number">2</span>, ret;<br>ret = (x &gt; y &gt; z);<br>cout &lt;&lt; ret &lt;&lt; endl;<br>ret = x &gt; y &gt; z;<br>cout &lt;&lt; ret &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>0<br>0</p><h2 id="ifdef-A与-if-A的区别"><a href="#ifdef-A与-if-A的区别" class="headerlink" title="#ifdef A与#if A的区别"></a>#ifdef A与#if A的区别</h2><p>#ifdef A 和 #if A 在某些情况下可以达到相同的效果，但在其他情况下可能会有一些差异。</p><p>#ifdef A 是条件编译预处理指令，用于判断标识符 A 是否已经被定义。如果 A 已经被定义，则条件成立，后续的代码会被编译；如果 A 没有被定义，则条件不成立，后续的代码会被忽略。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> A</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> A</span><br>    <span class="hljs-comment">// 后续的代码会被编译</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>#if A 也是条件编译预处理指令，它可以用来进行更加灵活的条件判断。A 可以是一个整数常量表达式（如 1、0、-5）或一个已经定义的标识符（如 #define B 后的判断 #if B）。</p><p>如果 A 的值为非零（true），则条件成立，后续的代码会被编译；如果 A 的值为零（false），则条件不成立，后续的代码会被忽略。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> A 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> A</span><br>    <span class="hljs-comment">// 后续的代码会被编译</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>需要注意的是，#if A 的条件判断是在预处理阶段进行的，而不是在运行时。因此，A 必须是在预处理阶段就能确定其值的常量表达式或已经定义的标识符。</p><p>综上所述，#ifdef A 和 #if A 在大多数情况下可以达到相同的效果，但如果 A 是一个复杂的条件判断，或者需要在预处理阶段使用表达式的值进行判断，那么使用 #if A 更加灵活。</p><h2 id="有一个宴会正在进行，宴会上一共有n个客人。这个客人中可能有一个特殊的客人，这个特殊的客人是所有客人都认识的-但是这个特殊的客人不认识其他任何人。假设我们只能向这些客人问这种问题-A是否认识B。在这种限制下我们如何用最少的提问数确定这位特殊客人的身份-这种最优方法一共有多少种"><a href="#有一个宴会正在进行，宴会上一共有n个客人。这个客人中可能有一个特殊的客人，这个特殊的客人是所有客人都认识的-但是这个特殊的客人不认识其他任何人。假设我们只能向这些客人问这种问题-A是否认识B。在这种限制下我们如何用最少的提问数确定这位特殊客人的身份-这种最优方法一共有多少种" class="headerlink" title="有一个宴会正在进行，宴会上一共有n个客人。这个客人中可能有一个特殊的客人，这个特殊的客人是所有客人都认识的,但是这个特殊的客人不认识其他任何人。假设我们只能向这些客人问这种问题:A是否认识B。在这种限制下我们如何用最少的提问数确定这位特殊客人的身份?这种最优方法一共有多少种?"></a>有一个宴会正在进行，宴会上一共有n个客人。这个客人中可能有一个特殊的客人，这个特殊的客人是所有客人都认识的,但是这个特殊的客人不认识其他任何人。假设我们只能向这些客人问这种问题:A是否认识B。在这种限制下我们如何用最少的提问数确定这位特殊客人的身份?这种最优方法一共有多少种?</h2><p>在这个问题中，我们可以使用图的概念来解决。</p><p>首先，我们将每个客人表示为图中的一个节点，并用边连接两个客人之间的认识关系。如果客人 A 认识客人 B，则在 A 和 B 之间存在一条有向边。</p><p>根据问题的描述，特殊客人是所有客人都认识的，但不认识其他任何人，意味着特殊客人的入度为 n-1，出度为 0。</p><p>为了确定特殊客人的身份，我们可以进行如下的操作：</p><ol><li>对于每个客人 i，询问其他所有客人是否认识客人 i。如果有任何一个客人回答认识客人 i，则客人 i 不可能是特殊客人，因为特殊客人不会被其他人认识。</li><li>根据回答的结果，统计每个客人被认识的次数。如果某个客人的被认识次数为 n-1，则该客人可能是特殊客人。</li></ol><p>这种方法的最小提问数应为 n-1，因为每个客人都需要被其他客人询问一次。而最优方法，即可能的情况数，取决于特殊客人的位置。特殊客人的位置可以有 n 种选择（每个客人都有可能是特殊客人），因此最优方法的情况数为 n 种。</p><p>综上所述，最少的提问数为 n-1，最优方法有 n 种情况。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种基于二叉堆数据结构的排序算法。它的主要思想是将待排序的元素构建成一个最大堆（或最小堆），然后不断从堆顶取出最大（或最小）元素，同时调整剩余元素使其重新满足堆的性质，最终得到一个有序的序列。</p><p>以下是堆排序的基本步骤：</p><ol><li><p>构建堆：将待排序的数组看作是完全二叉树，根据堆的性质，从最后一个非叶子节点开始，对每个节点进行下沉操作（即与其左右子节点比较并交换），直到根节点。这样就可以将待排序的数组构建成一个最大堆或最小堆。</p></li><li><p>排序：将堆顶元素（最大值或最小值）与数组末尾元素交换，然后将数组长度减少1（相当于将最大（或最小）元素从堆中移除）。接着再次对堆顶元素进行下沉操作，使剩余元素重新满足堆的性质。</p></li><li><p>重复上述步骤，直到堆中只剩下一个元素，此时数组就变成了有序的序列。</p></li></ol><p>堆排序的时间复杂度为O(nlogn)，其中n是待排序数组的长度。它是一种原地排序算法，不需要使用额外的空间来存储中间结果。堆排序是一种稳定的排序算法，适用于大数据量的排序。</p><p>然而，堆排序的实现相对复杂，需要熟悉二叉堆的性质和操作。由于数据访问的不连续性和频繁的元素交换，堆排序的缓存命中率较低，可能导致相对较慢的运行速度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 停止条件：当前来到头结点或者当前节点不在比它的父节点大</span><br>    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>        index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> heapSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; heapSize)<br>    &#123;<br>        <span class="hljs-comment">// two children choose bigger one</span><br>        <span class="hljs-type">int</span> largest = left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;<br>        <span class="hljs-comment">// 父和较大孩子之间，谁的值大，把下标给largest</span><br>        largest = arr[largest] &gt; arr[index] ? largest : index;<br>        <span class="hljs-keyword">if</span> (index == largest)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr, largest, index);<br>        index = largest;<br>        left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// O(N)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-comment">// O(logN)</span><br>        <span class="hljs-built_in">heapInsert</span>(arr, i);<br>    &#125;<br>    <span class="hljs-type">int</span> heapSize = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">swap</span>(arr, <span class="hljs-number">0</span>, --heapSize);<br>    <span class="hljs-comment">// O(N)</span><br>    <span class="hljs-keyword">while</span> (heapSize &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// O(logN)</span><br>        <span class="hljs-built_in">heapify</span>(arr, <span class="hljs-number">0</span>, heapSize);<br>        <span class="hljs-comment">// O(1)</span><br>        <span class="hljs-built_in">swap</span>(arr, <span class="hljs-number">0</span>, --heapSize);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是一种基于分治思想的排序算法，它的主要思想是将待排序的数组分成两个子数组，对每个子数组进行递归排序，最后将两个有序的子数组合并成一个有序的数组。</p><p>以下是归并排序的基本步骤：</p><ul><li><p>分割：将待排序数组从中间位置分成两个子数组，对每个子数组进行递归排序，直到子数组长度为1。</p></li><li><p>合并：将两个有序的子数组合并成一个有序的数组。合并时，需要定义一个临时数组，用于存储两个子数组合并后的结果。从头开始比较两个子数组的元素，选取较小的元素放入临时数组中；当一个子数组中的元素全部取完时，直接将另一个子数组中的剩余元素放入临时数组后面。</p></li><li><p>重复上述步骤，直到所有子数组合并成一个有序的数组。</p></li></ul><p>归并排序的时间复杂度为O(nlogn)，其中n是待排序数组的长度。由于归并排序是一种稳定的排序算法，并且不依赖于数据的初始状态，因此它适用于各种排序场景。</p><p>归并排序相比于其他排序算法，如快速排序和堆排序，实现相对简单。但它需要额外的空间来存储临时结果，因此在处理大数据量时可能会有空间限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 归并排序（C-迭代版）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &lt; y ? x : y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *a = arr;<br>    <span class="hljs-type">int</span> *b = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(len * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-type">int</span> seg, start;<br>    <span class="hljs-keyword">for</span> (seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (start = <span class="hljs-number">0</span>; start &lt; len; start += seg + seg)<br>        &#123;<br>            <span class="hljs-type">int</span> low = start, mid = <span class="hljs-built_in">min</span>(start + seg, len), high = <span class="hljs-built_in">min</span>(start + seg + seg, len);<br>            <span class="hljs-type">int</span> k = low;<br>            <span class="hljs-type">int</span> start1 = low, end1 = mid;<br>            <span class="hljs-type">int</span> start2 = mid, end2 = high;<br>            <span class="hljs-keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)<br>                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];<br>            <span class="hljs-keyword">while</span> (start1 &lt; end1)<br>                b[k++] = a[start1++];<br>            <span class="hljs-keyword">while</span> (start2 &lt; end2)<br>                b[k++] = a[start2++];<br>        &#125;<br>        <span class="hljs-type">int</span> *temp = a;<br>        a = b;<br>        b = temp;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a != arr)<br>    &#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            b[i] = a[i];<br>        b = a;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(b);<br>&#125;<br><br><span class="hljs-comment">// 归并排序（C-递归版）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort_recursive</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> reg[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= end)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> len = end - start, mid = (len &gt;&gt; <span class="hljs-number">1</span>) + start;<br>    <span class="hljs-type">int</span> start1 = start, end1 = mid;<br>    <span class="hljs-type">int</span> start2 = mid + <span class="hljs-number">1</span>, end2 = end;<br>    <span class="hljs-built_in">merge_sort_recursive</span>(arr, reg, start1, end1);<br>    <span class="hljs-built_in">merge_sort_recursive</span>(arr, reg, start2, end2);<br>    <span class="hljs-type">int</span> k = start;<br>    <span class="hljs-keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)<br>        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];<br>    <span class="hljs-keyword">while</span> (start1 &lt;= end1)<br>        reg[k++] = arr[start1++];<br>    <span class="hljs-keyword">while</span> (start2 &lt;= end2)<br>        reg[k++] = arr[start2++];<br>    <span class="hljs-keyword">for</span> (k = start; k &lt;= end; k++)<br>        arr[k] = reg[k];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">const</span> <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> reg[len];<br>    <span class="hljs-built_in">merge_sort_recursive</span>(arr, reg, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建第一个x86的hello world</title>
    <link href="/2023/07/28/%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAx86%E7%9A%84hello-world/"/>
    <url>/2023/07/28/%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAx86%E7%9A%84hello-world/</url>
    
    <content type="html"><![CDATA[<p>bochs生成bochsrc配置文件，并将执行选项修改为”gui_debug”</p><p>bxiamge 创建一个硬盘，并设置大小为 16M</p><p>将最终产生的脚本添加到bochsrc的配置文件当中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">configuration file generated by Bochs</span><br>plugin_ctrl: unmapped=true, biosdev=true, speaker=true, extfpuirq=true, parallel=true, serial=true, iodebug=true<br>config_interface: textconfig<br><span class="hljs-meta prompt_"># </span><span class="language-bash">modfiy</span><br>display_library: x, options=&quot;gui_debug&quot;<br>memory: host=32, guest=32<br>romimage: file=&quot;/usr/local/share/bochs/BIOS-bochs-latest&quot;, address=0x00000000, options=none<br>vgaromimage: file=&quot;/usr/local/share/bochs/VGABIOS-lgpl-latest&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">modify</span><br>boot: disk<br>floppy_bootsig_check: disabled=0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">no floppya</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">no floppyb</span><br>ata0: enabled=true, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14<br><span class="hljs-meta prompt_"># </span><span class="language-bash">modify</span><br>ata0-master: type=disk, path=&quot;master.img&quot;, mode=flat<br>ata0-slave: type=none<br>ata1: enabled=true, ioaddr1=0x170, ioaddr2=0x370, irq=15<br>ata1-master: type=none<br>ata1-slave: type=none<br>ata2: enabled=false<br>ata3: enabled=false<br>optromimage1: file=none<br>optromimage2: file=none<br>optromimage3: file=none<br>optromimage4: file=none<br>optramimage1: file=none<br>optramimage2: file=none<br>optramimage3: file=none<br>optramimage4: file=none<br>pci: enabled=1, chipset=i440fx<br>vga: extension=vbe, update_freq=5, realtime=1<br>cpu: count=1, ips=4000000, model=bx_generic, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0<br>cpuid: level=6, stepping=3, model=3, family=6, vendor_string=&quot;GenuineIntel&quot;, brand_string=&quot;              Intel(R) Pentium(R) 4 CPU        &quot;<br>cpuid: mmx=true, apic=xapic, simd=sse2, sse4a=false, misaligned_sse=false, sep=true<br>cpuid: movbe=false, adx=false, aes=false, sha=false, xsave=false, xsaveopt=false, smep=false<br>cpuid: smap=false, mwait=true<br>print_timestamps: enabled=0<br>debugger_log: -<br>magic_break: enabled=0<br>port_e9_hack: enabled=0<br>private_colormap: enabled=0<br>clock: sync=none, time0=local, rtc_sync=0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">no cmosimage</span><br>log: -<br>logprefix: %t%e%d<br>debug: action=ignore<br>info: action=report<br>error: action=report<br>panic: action=ask<br>keyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=none<br>mouse: type=ps2, enabled=false, toggle=ctrl+mbutton<br>speaker: enabled=true, mode=system<br>parport1: enabled=true, file=none<br>parport2: enabled=false<br>com1: enabled=true, mode=null<br>com2: enabled=false<br>com3: enabled=false<br>com4: enabled=false<br></code></pre></td></tr></table></figure><p>利用 <code>bximage</code> 创建扁平格式硬盘映像文件</p><p>上述命令用于创建一个16MB大小、扇区大小为512字节的扁平格式硬盘映像文件 master.img。</p><p><code>yes | bximage -q -hd=16 -mode=create -sectsize=512 -imgmode=flat master.img</code> 这个命令的含义如下：</p><ul><li><code>yes</code> 是一个命令，用于重复输出 “y”（表示同意）。</li><li><code>|</code> 是管道操作符，用于将一个命令的输出作为另一个命令的输入。</li><li><code>bximage</code> 是一个用于创建硬盘映像文件的工具。</li><li><code>-q</code> 参数表示“安静模式”，在不需要进一步确认的情况下运行命令。</li><li><code>-hd=16</code> 参数指定硬盘映像文件的大小为16MB。</li><li><code>-mode=create</code> 参数表示创建一个新的硬盘映像文件。</li><li><code>-sectsize=512</code> 参数指定扇区大小为512字节。</li><li><code>-imgmode=flat</code> 参数表示使用扁平格式作为映像文件的类型。</li><li><code>master.img</code> 是要创建的硬盘映像文件的文件名。</li></ul><p>利用dd命令将hello.asm加入硬盘当中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs asm">[bits 32]<br><br>; extern printf<br>; extern exit<br><br>; section .text<br>; global main<br>; main:<br>;     push message<br>;     call printf<br>;     add esp, 4<br><br>;     push 0<br>;     call exit<br><br>; section .data<br>;     message db &quot;hello world!!!&quot;, 10, 13, 0<br>;     message_end:<br><br>section .text<br>global main<br>main:<br><br>    mov eax, 4; write<br>    mov ebx, 1; stdout<br>    mov ecx, message; buffer<br>    mov edx, message_end - message<br>    int 0x80<br><br>    mov eax, 1; exit<br>    mov ebx, 0; status<br>    int 0x80<br><br>section .data<br>    message db &quot;hello world!!!&quot;, 10, 13, 0<br>    message_end:<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dd if=hello.bin of=master.img bs=512 count=1 conv=notrunc<br></code></pre></td></tr></table></figure><p>这个命令使用<code>dd</code>工具将<code>hello.bin</code>文件的内容复制到<code>master.img</code>文件中，每次复制512字节，只复制一次，并且不截断目标文件。</p><p>下面是对该命令中使用的参数的解释：</p><ul><li><code>if=hello.bin</code>：指定输入文件的路径和名称为<code>hello.bin</code>。</li><li><code>of=master.img</code>：指定输出文件的路径和名称为<code>master.img</code>。</li><li><code>bs=512</code>：指定每个读取和写入操作的块大小为512字节。</li><li><code>count=1</code>：指定只进行一次复制操作。</li><li><code>conv=notrunc</code>：表示不截断目标文件，在写入之前保留目标文件的现有内容。</li></ul><p>请确保在运行该命令之前，<code>hello.bin</code>和<code>master.img</code>文件都存在，并且目标文件<code>master.img</code>的大小足够容纳源文件<code>hello.bin</code>的内容，否则可能会导致数据丢失或截断。</p><p>最终构建项目的 makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%.bin: %.asm</span><br><span class="hljs-comment"># $&lt; 是输入文件; $@ 是输出文件</span><br>nasm <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">master.img: boot.bin</span><br>dd if=boot.bin of=master.img bs=512 count=1 conv=notrunc<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:bochs</span><br><span class="hljs-comment"># 因为bochs的执行是需要master.img文件的，所以将它添加到依赖上</span><br><span class="hljs-section">bochs:master.img</span><br>bochs -q<br><br><span class="hljs-comment"># 伪目标，每次都会执行，而对于其他目标make之后有可能是 up to date</span><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean</span><br><span class="hljs-section">clean:</span><br>rm -rf *.bin<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>x86</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bochs的基本使用教程</title>
    <link href="/2023/07/28/bochs%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2023/07/28/bochs%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>Bochs是一款x86模拟器，可以用于模拟运行x86架构的操作系统和软件。下面是Bochs的一些基本使用方式：</p><ol><li><p>启动Bochs：可以在终端中运行以下命令来启动Bochs：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bochs</span><br></code></pre></td></tr></table></figure><p>这将使用默认的bochsrc配置文件启动Bochs模拟器。</p></li><li><p>使用自定义配置文件：如果您有一个自定义的bochsrc配置文件，可以通过以下命令来指定它：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">bochs -f <span class="hljs-regexp">/path/</span>to/bochsrc<br></code></pre></td></tr></table></figure><p>将<code>/path/to/bochsrc</code>替换为您的自定义配置文件的路径。</p></li><li><p>使用命令行选项：您可以在启动Bochs时使用一些命令行选项来更改配置。例如，可以使用<code>-q</code>选项以静默模式启动Bochs，或者使用<code>-rc</code>选项指定一个附加的rc脚本文件。</p></li><li><p>调试模式：Bochs还提供了调试功能，可以用于在模拟器中进行调试操作系统或程序。您可以使用以下命令启动Bochs的调试模式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">bochs -q -rc <span class="hljs-regexp">/path/</span>to/debugger.bxrc<br></code></pre></td></tr></table></figure><p>这里<code>/path/to/debugger.bxrc</code>是包含调试器相关设置的bxrc脚本文件。在调试模式下，您可以使用一系列的调试命令，例如设置断点、单步执行、查看寄存器值等。</p></li><li><p>退出Bochs：要退出Bochs模拟器，可以在控制台中运行<code>quit</code>或<code>exit</code>命令，或者使用快捷键<code>Ctrl + Alt + Del</code>。</p></li><li><p>bochs生成配置文件并修改为gui_debug</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs shell">whc@whc-virtual-machine:~/code/gitRep/os/computer/x86_assembly/tests$ bochs<br>========================================================================<br>                       Bochs x86 Emulator 2.6.11<br>              Built from SVN snapshot on January 5, 2020<br>                Timestamp: Sun Jan  5 08:36:00 CET 2020<br>========================================================================<br>00000000000i[      ] BXSHARE not set. using compile time default &#x27;/usr/local/share/bochs&#x27;<br>------------------------------<br>Bochs Configuration: Main Menu<br>------------------------------<br><br>This is the Bochs Configuration Interface, where you can describe the<br>machine that you want to simulate.  Bochs has already searched for a<br>configuration file (typically called bochsrc.txt) and loaded it if it<br>could be found.  When you are satisfied with the configuration, go<br>ahead and start the simulation.<br><br>You can also start bochs with the -q option to skip these menus.<br><br>1. Restore factory default configuration<br>2. Read options from...<br>3. Edit options<br>4. Save options to...<br>5. Restore the Bochs state from...<br>6. Begin simulation<br>7. Quit now<br><br>Please choose one: [2] 4<br>Save configuration to what file?  To cancel, type &#x27;none&#x27;.<br>[none] bochsrc<br>00000000000i[      ] write current configuration to bochsrc<br>Wrote configuration to &#x27;bochsrc&#x27;.<br>------------------------------<br>Bochs Configuration: Main Menu<br>------------------------------<br><br>This is the Bochs Configuration Interface, where you can describe the<br>machine that you want to simulate.  Bochs has already searched for a<br>configuration file (typically called bochsrc.txt) and loaded it if it<br>could be found.  When you are satisfied with the configuration, go<br>ahead and start the simulation.<br><br>You can also start bochs with the -q option to skip these menus.<br><br>1. Restore factory default configuration<br>2. Read options from...<br>3. Edit options<br>4. Save options to...<br>5. Restore the Bochs state from...<br>6. Begin simulation<br>7. Quit now<br><br>Please choose one: [2] 7<br>00000000000i[SIM   ] quit_sim called with exit code 1<br></code></pre></td></tr></table></figure><p>bochsrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">configuration file generated by Bochs</span><br>plugin_ctrl: unmapped=true, biosdev=true, speaker=true, extfpuirq=true, parallel=true, serial=true, iodebug=true<br>config_interface: textconfig<br>display_library: x, options=&quot;gui_debug&quot;<br>memory: host=32, guest=32<br>romimage: file=&quot;/usr/local/share/bochs/BIOS-bochs-latest&quot;, address=0x00000000, options=none<br>vgaromimage: file=&quot;/usr/local/share/bochs/VGABIOS-lgpl-latest&quot;<br>boot: floppy<br>floppy_bootsig_check: disabled=0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">no floppya</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">no floppyb</span><br>ata0: enabled=true, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14<br>ata0-master: type=none<br>ata0-slave: type=none<br>ata1: enabled=true, ioaddr1=0x170, ioaddr2=0x370, irq=15<br>ata1-master: type=none<br>ata1-slave: type=none<br>ata2: enabled=false<br>ata3: enabled=false<br>optromimage1: file=none<br>optromimage2: file=none<br>optromimage3: file=none<br>optromimage4: file=none<br>optramimage1: file=none<br>optramimage2: file=none<br>optramimage3: file=none<br>optramimage4: file=none<br>pci: enabled=1, chipset=i440fx<br>vga: extension=vbe, update_freq=5, realtime=1<br>cpu: count=1, ips=4000000, model=bx_generic, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0<br>cpuid: level=6, stepping=3, model=3, family=6, vendor_string=&quot;GenuineIntel&quot;, brand_string=&quot;              Intel(R) Pentium(R) 4 CPU        &quot;<br>cpuid: mmx=true, apic=xapic, simd=sse2, sse4a=false, misaligned_sse=false, sep=true<br>cpuid: movbe=false, adx=false, aes=false, sha=false, xsave=false, xsaveopt=false, smep=false<br>cpuid: smap=false, mwait=true<br>print_timestamps: enabled=0<br>debugger_log: -<br>magic_break: enabled=0<br>port_e9_hack: enabled=0<br>private_colormap: enabled=0<br>clock: sync=none, time0=local, rtc_sync=0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">no cmosimage</span><br>log: -<br>logprefix: %t%e%d<br>debug: action=ignore<br>info: action=report<br>error: action=report<br>panic: action=ask<br>keyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=none<br>mouse: type=ps2, enabled=false, toggle=ctrl+mbutton<br>speaker: enabled=true, mode=system<br>parport1: enabled=true, file=none<br>parport2: enabled=false<br>com1: enabled=true, mode=null<br>com2: enabled=false<br>com3: enabled=false<br>com4: enabled=false<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>bochs2.6.11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bochs2.6.11 install</title>
    <link href="/2023/07/28/bochs2-6-11-install/"/>
    <url>/2023/07/28/bochs2-6-11-install/</url>
    
    <content type="html"><![CDATA[<h2 id="源码安装bochs2-6-11"><a href="#源码安装bochs2-6-11" class="headerlink" title="源码安装bochs2.6.11"></a>源码安装bochs2.6.11</h2><p>要在 <code>Ubuntu18.06</code> 上进行 <code>Bochs 2.6.11</code> 的源码安装，您可以按照以下步骤进行操作：</p><ol><li><p>下载Bochs源代码：首先，您需要下载Bochs 2.6.11的源代码包。您可以在Bochs的官方网站（<a href="http://bochs.sourceforge.net/%EF%BC%89%E6%88%96GitHub%E5%AD%98%E5%82%A8%E5%BA%93%EF%BC%88https://github.com/bochs/bochs%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8C%85%E3%80%82%E5%B0%86%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%82%A8%E7%9A%84Ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%AD%E3%80%82">http://bochs.sourceforge.net/）或GitHub存储库（https://github.com/bochs/bochs）上找到源代码包。将源代码包下载到您的Ubuntu系统中。</a></p></li><li><p>安装必要的依赖项：在编译和安装Bochs之前，您需要安装一些必要的依赖项。打开终端并执行以下命令安装所需的软件包：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span><br>sudo apt-<span class="hljs-built_in">get</span> install build-essential libx11-<span class="hljs-built_in">dev</span> xorg-<span class="hljs-built_in">dev</span> libgtk2<span class="hljs-number">.0</span>-<span class="hljs-built_in">dev</span> libjpeg-<span class="hljs-built_in">dev</span> libpng-<span class="hljs-built_in">dev</span> libasound2-<span class="hljs-built_in">dev</span> libssl-<span class="hljs-built_in">dev</span> libsdl1<span class="hljs-number">.2</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure></li><li><p>解压源代码包：将下载的Bochs源代码包解压到一个合适的目录中。</p></li><li><p>进入源代码目录：在终端中，使用<code>cd</code>命令进入解压后的Bochs源代码目录。</p></li></ol><p>由于<code>bochs</code>的仓库年久失修，所以建议按照这个建议修改两个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">Description: Fix the build with SMP enabled<br>Origin: https://sourceforge.net/p/bochs/code/13778/<br><br>Index: bochs/bx_debug/dbg_main.cc<br>===================================================================<br>--- bochs/bx_debug/dbg_main.cc(revision 13777)<br>+++ bochs/bx_debug/dbg_main.cc(working copy)<br>@@ -1494,11 +1494,11 @@<br> &#123;<br>   char cpu_param_name[16];<br> <br>-  Bit32u index = BX_ITLB_INDEX_OF(laddr);<br>+  Bit32u index = BX_CPU(dbg_cpu)-&gt;ITLB.get_index_of(laddr);<br>   sprintf(cpu_param_name, &quot;ITLB.entry%d&quot;, index);<br>   bx_dbg_show_param_command(cpu_param_name, 0);<br> <br>-  index = BX_DTLB_INDEX_OF(laddr, 0);<br>+  index = BX_CPU(dbg_cpu)-&gt;DTLB.get_index_of(laddr);<br>   sprintf(cpu_param_name, &quot;DTLB.entry%d&quot;, index);<br>   bx_dbg_show_param_command(cpu_param_name, 0);<br> &#125;<br><br>Index: bochs/gui/gtk_enh_dbg_osdep.cc<br>===================================================================<br>--- bochs/gui/gtk_enh_dbg_osdep.cc<br>+++ bochs/gui/gtk_enh_dbg_osdep.cc<br>@@ -819,7 +819,7 @@ void ShowDListCols (int totcols)<br>     while (++i &lt; firsthide)<br>         gtk_tree_view_column_set_visible(AllCols[i], TRUE);<br>     while (i &lt; 23)<br>-        gtk_tree_view_column_set_visible(AllCols[i], FALSE);<br>+        gtk_tree_view_column_set_visible(AllCols[i++], FALSE);<br> &#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>配置和编译：</li></ol><p>修改完之后如果需要gdb远程调试功能需要将解压出来的源码包一式两份，拷贝为两个文件夹的名字分别是<code>bochs-2.6.11</code>（配置自带调试功能）和<code>bochsgdb-2.6.11</code>（配置gdb远程调试功能）。</p><p>如果之前安装过<code>bochs</code>需要卸载，<code>apt remove</code> 卸载<code>apt</code>安装的包，源码卸载方式是进入源码安装文件夹<code>sudo make uninstall</code></p><p>安装 bochs<br>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">--prefix=/usr/local/ 这里修改为你自己想要指定的安装路径</span><br>./configure --prefix=/usr/local/ --with-x11 --with-wx --enable-debugger --enable-disasm --enable-all-optimizations --enable-readline --enable-long-phy-address --enable-ltdl-install --enable-idle-hack --enable-plugins --enable-a20-pin --enable-x86-64 --enable-smp --enable-cpu-level=6 --enable-large-ramfile --enable-repeat-speedups --enable-fast-function-calls  --enable-handlers-chaining  --enable-trace-linking --enable-configurable-msrs --enable-show-ips  --enable-debugger-gui --enable-iodebug --enable-logging --enable-assert-checks --enable-fpu --enable-vmx=2 --enable-svm --enable-3dnow --enable-alignment-check  --enable-monitor-mwait --enable-avx  --enable-evex --enable-x86-debugger --enable-pci --enable-usb --enable-voodoo<br><br>make<br>sudo make install<br></code></pre></td></tr></table></figure></p><p>安装 bochs-gdb</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">--prefix=/home/whc/code/optFile/bochsgdb 这里修改为你自己想要指定的安装路径</span><br>./configure --prefix=/home/whc/code/optFile/bochsgdb --with-x11 --with-wx --enable-disasm --enable-all-optimizations --enable-readline --enable-long-phy-address --enable-ltdl-install --enable-idle-hack --enable-plugins --enable-a20-pin --enable-x86-64 --enable-cpu-level=6 --enable-large-ramfile --enable-repeat-speedups --enable-fast-function-calls  --enable-handlers-chaining  --enable-trace-linking --enable-configurable-msrs --enable-show-ips  --enable-debugger-gui --enable-iodebug --enable-logging --enable-assert-checks --enable-fpu --enable-vmx=2 --enable-svm --enable-3dnow --enable-alignment-check  --enable-monitor-mwait --enable-avx  --enable-evex --enable-x86-debugger --enable-pci --enable-usb --enable-voodoo -enable-gdb-stub<br><br>make<br>sudo make install<br></code></pre></td></tr></table></figure><p>然后我们还要做一件事：对这个新的<code>bochs</code>重命名，让它和之前的<code>bochs</code>区分。</p><p>我们只需要进入安装<code>bochs-gdb</code>的目录，然后执行以下命令</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd bin<br>sudo mv bochs bochs-gdb<br>sudo mv bximage bximage-gdb<br></code></pre></td></tr></table></figure><p>然后修改 <code>~/.bashrc</code> 或者 <code>~/.zshrc</code> （取决于你用什么shell）<br>加入下面两行</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export PATH=/usr/local/bochs/bin:$PATH<br>export PATH=/home/whc/code/optFile/bin:$PATH<br></code></pre></td></tr></table></figure><ol start="6"><li><p>安装完成后，您可以尝试运行Bochs来验证安装是否成功。在新建终端中输入以下命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">bochs</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>bochs2.6.11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>personalBlog</title>
    <link href="/2023/07/18/personalBlog/"/>
    <url>/2023/07/18/personalBlog/</url>
    
    <content type="html"><![CDATA[<h2 id="blog建立和维护"><a href="#blog建立和维护" class="headerlink" title="blog建立和维护"></a>blog建立和维护</h2><h3 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h3><p>强烈建议去搞个速度快的tizi</p><p>参考博文 <a href="https://blog.csdn.net/yaorongke/article/details/119089190" title="参考博文">参考博文</a>。</p><p>参考博文 <a href="https://zhuanlan.zhihu.com/p/60578464" title="参考博文">参考博文</a>。</p><h3 id="上传博客"><a href="#上传博客" class="headerlink" title="上传博客"></a>上传博客</h3><h4 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h4><p>hexo new post “测试文章”</p><h4 id="更新文章"><a href="#更新文章" class="headerlink" title="更新文章"></a>更新文章</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br>hexo g -d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WHC2Enable</title>
    <link href="/2023/07/18/WHC2Enable/"/>
    <url>/2023/07/18/WHC2Enable/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="2023/07/18/WHC2Enable/lxq1.jpg" class="" title="图片引用方法一"><p><img src="lxq1.jpg" alt="图片引用方法二"></p><p><img src="/images/lxq1.jpg" alt="图片引用方法三"></p>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/07/18/hello-world/"/>
    <url>/2023/07/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
