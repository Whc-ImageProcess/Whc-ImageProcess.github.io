

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="../../../../img/fluid.png">
  <link rel="icon" href="../../../../img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="WHC">
  <meta name="keywords" content="">
  
    <meta name="description" content="初始化列表在C++中，初始化列表（initializer list）是用于初始化类成员变量的一种方式。以下是必须在初始化列表中初始化的情况：  常量成员变量（const）：由于常量成员变量在创建对象时必须进行初始化，因此它们必须在初始化列表中初始化。  引用成员变量（reference）：引用必须在创建对象时初始化，并且一旦初始化后，就不能再引用其他对象。因此，引用成员变量必须在初始化列表中初始化">
<meta property="og:type" content="article">
<meta property="og:title" content="cppNotes">
<meta property="og:url" content="http://example.com/2023/08/13/cppNotes/index.html">
<meta property="og:site_name" content="WHC2Enable">
<meta property="og:description" content="初始化列表在C++中，初始化列表（initializer list）是用于初始化类成员变量的一种方式。以下是必须在初始化列表中初始化的情况：  常量成员变量（const）：由于常量成员变量在创建对象时必须进行初始化，因此它们必须在初始化列表中初始化。  引用成员变量（reference）：引用必须在创建对象时初始化，并且一旦初始化后，就不能再引用其他对象。因此，引用成员变量必须在初始化列表中初始化">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-13T08:45:00.000Z">
<meta property="article:modified_time" content="2023-10-02T13:54:04.444Z">
<meta property="article:author" content="WHC">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>cppNotes - WHC2Enable</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="../../../../css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="../../../../css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="../../../../css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"23sq65MU7rrVFz0XjoKRZuMM-gzGzoHsz","app_key":"5J5wrPRqIyjTgcZsPvLLlfvc","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="../../../../js/utils.js" ></script>
  <script  src="../../../../js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="../../../../index.html">
      <strong>WHC2Enable BLOG</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../index.html">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('../../../../img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="cppNotes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-13 16:45" pubdate>
          2023年8月13日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          90 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">cppNotes</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>在C++中，初始化列表（initializer list）是用于初始化类成员变量的一种方式。以下是必须在初始化列表中初始化的情况：</p>
<ul>
<li><p>常量成员变量（const）：由于常量成员变量在创建对象时必须进行初始化，因此它们必须在初始化列表中初始化。</p>
</li>
<li><p>引用成员变量（reference）：引用必须在创建对象时初始化，并且一旦初始化后，就不能再引用其他对象。因此，引用成员变量必须在初始化列表中初始化。</p>
</li>
<li><p>成员变量对象（member object）：如果类包含其他类的对象作为成员变量，而这些成员对象没有默认构造函数或者需要传递参数进行初始化，那么它们必须在初始化列表中初始化。</p>
</li>
</ul>
<p>以下是不能在初始化列表中初始化的情况：</p>
<ul>
<li><p>静态成员变量（static）：静态成员变量在类定义外进行初始化，而不是在构造函数或初始化列表中。</p>
</li>
<li><p>父类的成员变量不能在子类的初始化列表中直接进行初始化，可以在父类的初始化列表中初始化</p>
</li>
</ul>
<h2 id="GCC编译器的结构体对齐指令"><a href="#GCC编译器的结构体对齐指令" class="headerlink" title="GCC编译器的结构体对齐指令"></a>GCC编译器的结构体对齐指令</h2><p>gcc推荐的结构体对齐指令</p>
<pre><code class="hljs">   __attribute__((packed))

   __attribute__((aligned(n)))
</code></pre>
<p>(1) <code>__attribute__((packed))</code>使用时直接放在要进行内存对齐的类型定义的后面，然后它起作用的范围只有加了这个东西的这一个类型。packed的作用就是取消对齐访问。</p>
<p>注意：定义变量时，加 <code>__attribute__((packed))</code> 是不起作用的，说明<code>__attribute__((packed))</code>只能加在结构体类型后面，只能影响这个结构体类型的整体自己。</p>
<p>(2) <code>__attribute__((aligned(n)))</code>使用时直接放在要进行内存对齐的类型定义的后面，然后它起作用的范围只有加了这个东西的这一个类型。它的作用是让整个结构体变量整体进行n字节对齐。</p>
<p>（注意<code>__attribute__((aligned(n)))</code>的作用是结构体变量整体n字节对齐，而不是结构体内各元素也要n字节对齐），这句话什么意思呢？简单理解：当32位编译器，默认对齐时4字节对齐，但是你会发现一个奇怪现象，当 <code>__attribute__((aligned(n)))</code>中的n&#x3D;1、2、4时，他的打印结果都是12（这是4字节对齐的结果：12&#x3D;4+2+2+4），因此可以看出，这里并不是要求结构体内部各元素都要按照n字节对齐，而是要求结构体整体对齐。只有当n的数值大于或等于4时（要求是2的幂次方）才会起作用。</p>
<h2 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h2><p>ACM 输入输出模式必学的技巧：getline 和 stringstream</p>
<p>getline 函数原型</p>
<p>template&lt; class CharT, class Traits, class Allocator &gt;<br>std::basic_istream&lt;CharT,Traits&gt;&amp; getline( std::basic_istream&lt;CharT,Traits&gt;&amp;&amp; input,<br>                                           std::basic_string&lt;CharT,Traits,Allocator&gt;&amp; str,<br>                                           CharT delim );</p>
<p>getline 从输入流读取字符并将它们放进 string ：</p>
<ol>
<li><p>表现为无格式输入函数 (UnformattedInputFunction) ，除了不影响 input.gcount() 。构造并检查 sentry 对象后，进行下列操作：</p>
<pre><code class="hljs">1. 调用 str.erase()

2. 从 input 释出字符并后附它们到 str ，直至发生下列条件之一（按顺序检查）：

       1. input 上的文件尾条件，该情况下， getline 设置 eofbit 。

       2. 下个可用输入字符是 delim ，以 Traits::eq(c, delim) 测试，该情况下从 input 释出分隔字符，但不后附它到 str 。

       3. 已经存储 str.max_size() 个字符，该情况下 getline 设置 failbit 并返回。

3. 若因任何原因（不是舍弃的分隔符）没有释出字符，则 getline 设置 failbit 并返回。
</code></pre>
</li>
<li><p>同 getline(input, str, input.widen(‘\n’)) ，即默认分隔符是换行符。</p>
</li>
</ol>
<ul>
<li>参数</li>
</ul>
<p><code>input</code>	-	获取数据来源的流<br><code>str</code>	-	放置数据的目标 string<br><code>delim</code>	-	分隔字符</p>
<ul>
<li>返回值</li>
</ul>
<p><code>input</code></p>
<ul>
<li>注解</li>
</ul>
<p>消耗空白符分隔的输入（例如 int n; std::cin &gt;&gt; n; ）时，任何后随的空白符，包括换行符都会被留在流中。然后当切换到面向行的输入时，以 getline 取得的首行只会是该空白符。多数情况下这是不想要的行为，可能的解法包括：</p>
<p>对 getline 的显式的额外初始调用<br>以 std::cin &gt;&gt; std::ws 移除额外的空白符<br>以 std::cin.ignore(std::numeric_limits<a href="std::streamsize">std::streamsize</a>::max(), ‘\n’); 忽略输入行上剩下的全部字符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    stringstream ss;<br>    string ip = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    ss &lt;&lt; ip;<br>    cout &lt;&lt; ss.<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br>    string mac;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(ss, mac, <span class="hljs-string">&#x27;.&#x27;</span>))<br>    &#123;<br>        cout &lt;&lt; mac &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string input;<br>    <span class="hljs-comment">// 在 windows 端输入 127.0.0.1 然后输入 ctrl+z ，再输入 enter</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, input, <span class="hljs-string">&#x27; &#x27;</span>))<br>    &#123;<br>        cout &lt;&lt; input &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 输出结果为 127 0 0 1 ；当标准输入接收为 eof 的时候就会返回 null</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// test1();</span><br>    <span class="hljs-built_in">test2</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h2><p>上面介绍完了lambda表达式的各个成分，其实很多部分和正常的函数没什么区别，其中最大的一个不同点就是捕获列表。我在刚开始用lambda表达式的时候，还一直以为这个没啥用，只是用一个 [] 来标志着这是一个lambda表达式。后来了解了才知道，原来这个捕获列表如此强大，甚至我觉得捕获列表就是lambda表达式的灵魂。下面先介绍几种常用的捕获方式。</p>
<p>[] 什么也不捕获，无法lambda函数体使用任何</p>
<p>[&#x3D;] 按值的方式捕获所有变量</p>
<p>[&amp;] 按引用的方式捕获所有变量</p>
<p>[&#x3D;, &amp;a] 除了变量a之外，按值的方式捕获所有局部变量，变量a使用引用的方式来捕获。这里可以按引用捕获多个，例如 [&#x3D;, &amp;a, &amp;b,&amp;c]。这里注意，如果前面加了&#x3D;，后面加的具体的参数必须以引用的方式来捕获，否则会报错。</p>
<p>[&amp;, a] 除了变量a之外，按引用的方式捕获所有局部变量，变量a使用值的方式来捕获。这里后面的参数也可以多个，例如 [&amp;, a, b, c]。这里注意，如果前面加了&amp;，后面加的具体的参数必须以值的方式来捕获。</p>
<p>[a, &amp;b] 以值的方式捕获a，引用的方式捕获b，也可以捕获多个。</p>
<p>[this] 在成员函数中，也可以直接捕获this指针，其实在成员函数中，[&#x3D;]和[&amp;]也会捕获this指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">5</span>;<br>    <br>    <span class="hljs-comment">// 按值来捕获</span><br>    <span class="hljs-keyword">auto</span> func1 = [a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;;<br>    <span class="hljs-built_in">func1</span>();<br><br>    <span class="hljs-comment">// 按值来捕获</span><br>    <span class="hljs-keyword">auto</span> func2 = [=] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;<br>    <span class="hljs-built_in">func2</span>();<br><br>    <span class="hljs-comment">// 按引用来捕获</span><br>    <span class="hljs-keyword">auto</span> func3 = [&amp;a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;;<br>    <span class="hljs-built_in">func3</span>();<br><br>    <span class="hljs-comment">// 按引用来捕获</span><br>    <span class="hljs-keyword">auto</span> func4 = [&amp;] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;<br>    <span class="hljs-built_in">func4</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="编译器如何看待Lambda表达式"><a href="#编译器如何看待Lambda表达式" class="headerlink" title="编译器如何看待Lambda表达式"></a>编译器如何看待Lambda表达式</h2><p>我们把lambda表达式看成一个函数，那编译器怎么看待我们协的lambda呢？</p>
<p>其实，编译器会把我们写的lambda表达式翻译成一个类，并重载 operator()来实现。比如我们写一个lambda表达式为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> plus = [] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>那么编译器会把我们写的表达式翻译为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类名是我随便起的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;;<br><br>LambdaClass plus;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>调用的时候编译器会生成一个Lambda的对象，并调用opeartor ()函数。（备注：这里的编译的翻译结果并不和真正的结果完全一致，只是把最主要的部分体现出来，其他的像类到函数指针的转换函数均省略）</p>
<p>上面是一种调用方式，那么如果我们写一个复杂一点的lambda表达式，表达式中的成分会如何与类的成分对应呢？我们再看一个 值捕获 例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> plus = [=] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> x + y + a + b; &#125;;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>编译器的翻译结果为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LambdaClass</span>(<span class="hljs-type">int</span> xx, <span class="hljs-type">int</span> yy)<br>    : <span class="hljs-built_in">x</span>(xx), <span class="hljs-built_in">y</span>(yy) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> x + y + a + b;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;<br><br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;<br><span class="hljs-function">LambdaClass <span class="hljs-title">plus</span><span class="hljs-params">(x, y)</span></span>;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>其实这里就可以看出，值捕获时，编译器会把捕获到的值作为类的成员变量，并且变量是以值的方式传递的。需要注意的时，如果所有的参数都是值捕获的方式，那么生成的operator()函数是const函数的，是无法修改捕获的值的，哪怕这个修改不会改变lambda表达式外部的变量，如果想要在函数内修改捕获的值，需要加上关键字 mutable。向下面这样的形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> plus = [=] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) <span class="hljs-keyword">mutable</span> -&gt; <span class="hljs-type">int</span> &#123; x++; <span class="hljs-keyword">return</span> x + y + a + b; &#125;;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<h2 id="引用的方式捕获变量"><a href="#引用的方式捕获变量" class="headerlink" title="引用的方式捕获变量"></a>引用的方式捕获变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> plus = [&amp;] (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> &#123; x++; <span class="hljs-keyword">return</span> x + y + a + b;&#125;;<br><span class="hljs-type">int</span> c = <span class="hljs-built_in">plus</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>编译器的翻译结果为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LambdaClass</span>(<span class="hljs-type">int</span>&amp; xx, <span class="hljs-type">int</span>&amp; yy)<br>    : <span class="hljs-built_in">x</span>(xx), <span class="hljs-built_in">y</span>(yy) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        x++;<br>        <span class="hljs-keyword">return</span> x + y + a + b;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> &amp;x;<br>    <span class="hljs-type">int</span> &amp;y;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>我们可以看到以引用的方式捕获变量，和值捕获的方式有3个不同的地方：</p>
<pre><code class="hljs">1. 参数引用的方式进行传递; 

2. 引用捕获在函数体修改变量，会直接修改lambda表达式外部的变量；

3. opeartor()函数不是const的。
</code></pre>
<p>针对上面的集中情况，我们把lambda的各个成分和类的各个成分对应起来就是如下的关系:</p>
<p>捕获列表，对应LambdaClass类的private成员。</p>
<p>参数列表，对应LambdaClass类的成员函数的operator()的形参列表</p>
<p>mutable，对应 LambdaClass类成员函数 operator() 的const属性 ，但是只有在捕获列表捕获的参数不含有引用捕获的情况下才会生效，因为捕获列表只要包含引用捕获，那operator()函数就一定是非const函数。</p>
<p>返回类型，对应 LambdaClass类成员函数 operator() 的返回类型</p>
<p>函数体，对应 LambdaClass类成员函数 operator() 的函数体。</p>
<p>引用捕获和值捕获不同的一点就是，对应的成员是否为引用类型。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/lambda">参考 cppreference</a></p>
<h1 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h1><p>1、引入 inline 关键字的原因<br>在 c&#x2F;c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。</p>
<p>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。</p>
<p>在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p>
<p>下面我们来看一个例子：</p>
<p>实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">num_check</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (v % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;奇&quot;</span> : <span class="hljs-string">&quot;偶&quot;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02d   %s\n&quot;</span>, i, <span class="hljs-built_in">num_check</span>(i));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的例子就是标准的内联函数的用法，使用 inline 修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个 for 循环的内部任何调用 num_check(i) 的地方都换成了 (i%2&gt;0)?”奇”:”偶”，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。</p>
<p>2、inline使用限制</p>
<p>inline 的使用是有所限制的，inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。</p>
<p>3、inline仅是一个对编译器的建议</p>
<p>inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</p>
<p>4、建议 inline 函数的定义放在头文件中</p>
<p>其次，因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。</p>
<p>因此，将内联函数的定义放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。</p>
<p>声明跟定义要一致：如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。</p>
<p>5、类中的成员函数与inline</p>
<p>定义在类中的成员函数默认都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;  &#125; <span class="hljs-comment">// 自动地成为内联函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 头文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br>&#125;<br> <br> <br><span class="hljs-comment">// 定义文件</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">A::Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>6、inline 是一种”用于实现的关键字”</p>
<p>关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。</p>
<p>如下风格的函数 Foo 不能成为内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>; <span class="hljs-comment">// inline 仅与函数声明放在一起</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>而如下风格的函数 Foo 则成为内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;&#125; <span class="hljs-comment">// inline 与函数定义体放在一起</span><br></code></pre></td></tr></table></figure>

<p>所以说，inline 是一种”用于实现的关键字”，而不是一种”用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++&#x2F;C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</p>
<p>7、慎用 inline</p>
<p>内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着”内联”这个关键字吗？<br>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。<br>如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p>
<p>以下情况不宜使用内联：<br>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。<br>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如”偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。</p>
<p>8、总结</p>
<p>内联函数并不是一个增强性能的灵丹妙药。只有当函数非常短小的时候它才能得到我们想要的效果；但是，如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大。<br>最令人烦恼的还是当编译器拒绝内联的时候。在老的实现中，结果很不尽人意，虽然在新的实现中有很大的改善，但是仍然还是不那么完善的。一些编译器能够足够的聪明来指出哪些函数可以内联哪些不能，但是大多数编译器就不那么聪明了，因此这就需要我们的经验来判断。如果内联函数不能增强性能，就避免使用它！</p>
<h2 id="面向对象设计的原则"><a href="#面向对象设计的原则" class="headerlink" title="面向对象设计的原则"></a>面向对象设计的原则</h2><p>面向对象设计（Object-Oriented Design，OOD）有许多原则和准则，下面是几个广为人知的重要原则：</p>
<ol>
<li><p>单一职责原则（Single Responsibility Principle，SRP）：<br>一个类应该只有一个引起它变化的原因。换句话说，一个类应该只有一个职责。这样可以提高类的可读性、可维护性和可测试性。</p>
</li>
<li><p>开放封闭原则（Open-Closed Principle，OCP）：<br>软件实体（类、模块、函数等）应该对扩展（变化）开放，而对修改关闭。这样可以保持系统的稳定性，同时方便添加新功能或修改现有功能。</p>
</li>
<li><p>里氏替换原则（Liskov Substitution Principle，LSP）：<br>子类对象应该能够替换其父类对象，并且程序不会产生错误或异常。这意味着子类应该遵循父类所定义的行为规范，而不改变父类的预期行为。</p>
</li>
<li><p>依赖倒置原则（Dependency Inversion Principle，DIP）：<br>高层模块不应该依赖于低层模块，而是应该依赖于抽象接口。通过依赖注入等方式，可以降低模块之间的耦合度，提高系统的可维护性和可测试性。</p>
</li>
<li><p>接口隔离原则（Interface Segregation Principle，ISP）：<br>客户端不应该依赖于它不需要的接口。一个类或模块只应该依赖于其需要的接口，避免对无用接口的依赖，从而减少耦合度。</p>
</li>
<li><p>迪米特法则（Law of Demeter，LoD）：<br>一个对象应该对其他对象有尽可能少的了解，也就是最小知道原则。对象之间的耦合越低，系统越灵活、可重用性越高。</p>
</li>
</ol>
<p>这些原则都是为了提高软件设计的质量和可维护性，通过降低耦合度、增加可复用性、提高扩展性等方面来实现优秀的面向对象设计。在实际应用中，根据具体情况和需求选择合适的原则，并结合设计模式等技术进行实践。</p>
<h2 id="c-中继承的特点"><a href="#c-中继承的特点" class="headerlink" title="c++中继承的特点"></a>c++中继承的特点</h2><p>C++ 中的继承是面向对象编程中的重要特性，它允许将一个类的特性和行为传递给另一个类，从而实现代码重用和组织。</p>
<p>C++ 中的继承具有以下几个特点：</p>
<ol>
<li><p>类的单继承和多继承：C++ 支持单继承和多继承。单继承是指一个类只有一个直接的父类，而多继承则是指一个类可以同时从多个父类继承属性和方法。多继承需要注意解决命名冲突等问题。</p>
</li>
<li><p>派生类增加新功能：通过继承，派生类可以获得基类的所有属性和方法，并且可以在此基础上添加自己的新功能。派生类可以添加新的成员函数，也可以覆盖（override）基类中的成员函数。</p>
</li>
<li><p>访问控制：C++ 中的继承也遵循访问控制规则，即公有继承、保护继承和私有继承。公有继承表示基类中的公有成员在派生类中仍然是公有的，保护继承表示基类中的公有成员在派生类中变为了保护成员，私有继承表示基类中的公有和保护成员在派生类中变为了私有成员。</p>
</li>
<li><p>构造函数和析构函数：C++ 中的构造函数和析构函数也可以被继承，派生类必须调用基类的构造函数来初始化从基类继承的成员变量和方法。析构函数的调用顺序与构造函数的调用顺序相反。</p>
</li>
<li><p>虚函数和多态：C++ 中的虚函数机制可以支持运行时多态。通过在基类中声明虚函数，并在派生类中覆盖它们，可以实现不同对象之间的动态绑定（dynamic binding）。这种特性可以方便地实现基于接口设计和实现等场景。</p>
</li>
</ol>
<p>总之，C++ 中的继承提供了一种强大的代码复用和组织机制，使得程序设计更加清晰、易于维护和扩展。但是，在使用继承时需要注意解决命名冲突、控制访问权限、避免继承深度过深等问题，以保证程序的正确性和可读性。</p>
<h2 id="类多继承需要注意什么"><a href="#类多继承需要注意什么" class="headerlink" title="类多继承需要注意什么"></a>类多继承需要注意什么</h2><p>在使用类多继承时，需要注意以下几点：</p>
<ol>
<li><p>命名冲突：多继承可能导致不同父类具有相同名称的成员（属性、方法等），这会引起命名冲突。为避免冲突，需要进行适当的命名空间管理或在派生类中使用完全限定名来引用成员。</p>
</li>
<li><p>虚函数与菱形继承问题：当存在多个父类时，并且其中某些类在继承关系中共享一个基类，就会出现所谓的菱形继承问题（也称菱形继承二义性）。例如，派生类 D 继承自两个基类 B 和 C，而 B 和 C 又都继承自基类 A。如果存在与 A 相关的虚函数，在 D 类中调用该虚函数可能会产生歧义。可以通过虚拟继承（virtual inheritance）来解决该问题，即在 B 和 C 继承 A 的地方使用 virtual 关键字。</p>
</li>
<li><p>父类构造函数调用：当一个类有多个父类时，需要确保每个父类的构造函数被正确调用来初始化它们的成员。在派生类的构造函数中，需要显式调用每个父类的构造函数，并按照正确的顺序传递参数。</p>
</li>
<li><p>类的设计复杂性：多继承可能引入更大的设计复杂性，增加代码的理解和维护难度。因此，在使用多继承时应慎重考虑，并遵循良好的设计原则，如单一职责原则、接口隔离原则等，以确保代码的可读性和可维护性。</p>
</li>
<li><p>合理使用多继承：多继承在某些情况下可以提供更灵活的设计方案，但也容易导致过度使用。应该评估是否真正需要多继承，以及是否可以通过其他方式（如组合、接口等）来达到相同的效果。</p>
</li>
</ol>
<p>总之，使用类多继承时需要注意处理命名冲突、避免菱形继承问题、正确调用父类构造函数，并合理设计和使用多继承，以确保代码的正确性、清晰性和可维护性。</p>
<h2 id="c-子类继承父类的过程中那些方法和成员变量不会被继承"><a href="#c-子类继承父类的过程中那些方法和成员变量不会被继承" class="headerlink" title="c++子类继承父类的过程中那些方法和成员变量不会被继承"></a>c++子类继承父类的过程中那些方法和成员变量不会被继承</h2><p>在 C++ 中，子类继承父类的过程中有一些方法和成员变量不会被继承，主要包括以下几种情况：</p>
<ol>
<li><p>父类的构造函数和析构函数：子类虽然可以继承父类的构造函数和析构函数，但并不是所有的都会被继承。例如，若父类中存在 private 型构造函数，则子类在继承时并不能直接调用该构造函数。</p>
</li>
<li><p>父类的赋值运算符（赋值操作符&#x3D;）: 子类继承父类时，父类中的赋值运算符不会被自动继承，需要手动定义子类中的赋值运算符。</p>
</li>
<li><p>父类中的 static 成员变量和静态方法：在子类中，static 成员变量和静态方法是属于父类并不会被子类继承。如果需要在子类中使用父类的 static 成员和静态方法，需要使用完全限定名来引用父类的成员。(但是在子类中是可以直接访问静态变量和静态方法的)</p>
</li>
<li><p>父类中的私有成员：由于私有成员只能被类本身访问，其他类不能访问私有成员。因此，子类无法继承父类中的私有成员，子类只能通过父类提供的公有接口或者受保护接口访问其私有成员。</p>
</li>
<li><p>父类的友元关系：子类一般不会继承父类中的友元关系，因为友元关系是建立在类之间的而非继承关系上。如果需要在子类中维护父类的友元关系，需要在子类中重新声明和定义相关的函数，并将其声明为友元函数。</p>
</li>
</ol>
<p>总之，子类继承父类时，虽然可以继承很多东西，但一些特殊的成员变量和方法并不会被自动继承。为了正确地继承和使用父类的成员，需要注意这些情况并适当地处理。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="../../../../categories/%E5%85%AB%E8%82%A1%E6%96%87/" class="category-chain-item">八股文</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="../../../../tags/cpp/" class="print-no-link">#cpp</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>cppNotes</div>
      <div>http://example.com/2023/08/13/cppNotes/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>WHC</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="../../29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">动态规划</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="../%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/" title="嵌入式面试八股文">
                        <span class="hidden-mobile">嵌入式面试八股文</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="../../../../js/events.js" ></script>
<script  src="../../../../js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="../../../../js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="../../../../js/leancloud.js" ></script>

  <script  src="../../../../js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="../../../../js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
